var di=Object.defineProperty,_i=Object.defineProperties;var mi=Object.getOwnPropertyDescriptors;var xe=Object.getOwnPropertySymbols;var pi=Object.prototype.hasOwnProperty,xi=Object.prototype.propertyIsEnumerable;var ye=(a,t,e)=>t in a?di(a,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[t]=e,rt=(a,t)=>{for(var e in t||(t={}))pi.call(t,e)&&ye(a,e,t[e]);if(xe)for(var e of xe(t))xi.call(t,e)&&ye(a,e,t[e]);return a},ut=(a,t)=>_i(a,mi(t));import{e as ft,bl as yi,bm as gi,b as B,r as N,bn as Ot,bo as Gt,bp as Zt,u as g,bq as Mi,s as st,S as ge,b0 as Kt,J as vi,K as wi,aX as bi,L as Si,q as wt,M as bt,x as Xt,br as Me,ay as Li,bs as Nt,bd as zi,bt as ve,bu as we,bv as be,h as Ti,p as Se,bw as Pi,bx as Ii,by as $i}from"./vendor.1906794a.js";import{Z as Ut,$ as Wi,o as nt,s as Ci,b as Le,e as F,j as Fi,Y as I,i as Ai,h as Ri,c as St,a as Ei,d as Bi,f as ze,S as ki,n as Di,g as Vi}from"./definitions.21e97413.js";import{f as Oi,a as Z,i as $,p as Gi}from"./visualVariablesUtils.c887ba43.js";import{E as z,z as Te,x as W,w,k as Zi,V as Ki}from"./Utils.dc5734bd.js";import{l as Xi}from"./tileUtils.38de3c83.js";import{n as Pe,r as Ni,a as Ui,b as Yi}from"./TileClipper.37214276.js";import{g as qi,a as Hi,A as ji,b as Qi,c as Ie,d as $e,n as We,e as Ji,f as tr,h as er}from"./CIMSymbolHelper.96d440ee.js";import{_ as Yt,e as ir,b as rr,U as Ce,B as Lt,x as dt,R as sr,L as qt}from"./MaterialKey.301bf49f.js";import{f as Ht,q as nr,i as zt,l as U,s as ar}from"./cimSymbolUtils.6ee77631.js";import{h as Fe,M as or}from"./GeometryUtils.ea8c8742.js";import"./earcut.f20dd8d8.js";function E(a,t){if(a&&"name"in a){const e=a;return t&&t.error(new ft(e.name,e.message,e.details)),!1}return!0}const lr=1.25;class Tt{constructor(t,e){this._pos=0;const i=e?this._roundToNearest(e,t.BYTES_PER_ELEMENT):40;this._array=new ArrayBuffer(i),this._buffer=new t(this._array),this._ctor=t,this._i16View=new Int16Array(this._array)}get length(){return this._pos}_roundToNearest(t,e){const i=Math.round(t);return i+(e-i%e)}_ensureSize(t){if(this._pos+t>=this._buffer.length){const e=this._roundToNearest((this._array.byteLength+t*this._buffer.BYTES_PER_ELEMENT)*lr,this._buffer.BYTES_PER_ELEMENT),i=new ArrayBuffer(e),r=new this._ctor(i);r.set(this._buffer,0),this._array=i,this._buffer=r,this._i16View=new Int16Array(this._array)}}ensureSize(t){this._ensureSize(t)}writeF32(t){this._ensureSize(1);const e=this._pos;return new Float32Array(this._array,4*this._pos,1)[0]=t,this._pos++,e}push(t){this._ensureSize(1);const e=this._pos;return this._buffer[this._pos++]=t,e}writeFixed(t){this._buffer[this._pos++]=t}setValue(t,e){this._buffer[t]=e}i1616Add(t,e,i){this._i16View[2*t]+=e,this._i16View[2*t+1]+=i}getValue(t){return this._buffer[t]}incr(t){if(this._buffer.length<t)throw new Error("Increment index overflows the target buffer");this._buffer[t]++}decr(t){this._buffer[t]--}writeRegion(t){this._ensureSize(t.length);const e=this._pos;return this._buffer.set(t,this._pos),this._pos+=t.length,e}writeManyFrom(t,e,i){this._ensureSize(i-e);for(let r=e;r!==i;r++)this.writeFixed(t._buffer[r])}buffer(){const t=this._array.slice(0,4*this._pos);return this.destroy(),t}toArray(){const t=this._array,e=[];for(let i=0;i<t.byteLength/4;i++)e.push(t[i]);return e}seek(t){this._pos=t}destroy(){this._array=null,this._buffer=null}}const at=new Map;function hr(a,t,e){const{indicesPerRecord:i,multiplier:r,verticesPerRecord:s}=at.get(a);return{recordBytes:e*Ut*Uint32Array.BYTES_PER_ELEMENT,indexBytes:r*i*e*Uint32Array.BYTES_PER_ELEMENT,vertexBytes:r*s*e*t}}at.set(z.MARKER,{multiplier:1,indicesPerRecord:6,verticesPerRecord:4}),at.set(z.LINE,{multiplier:1,indicesPerRecord:24,verticesPerRecord:8}),at.set(z.FILL,{multiplier:1,indicesPerRecord:10,verticesPerRecord:10}),at.set(z.TEXT,{multiplier:8,indicesPerRecord:6,verticesPerRecord:4}),at.set(z.LABEL,{multiplier:8,indicesPerRecord:6,verticesPerRecord:4});class Ae{constructor(t,e,i){this._start={index:0,vertex:0};const r=hr(t,e,i),s=e/4;this.geometryType=t,this._records=new Tt(Int32Array,r.recordBytes),this._indices=new Tt(Uint32Array,r.indexBytes),this._vertices=new Tt(Uint32Array,r.vertexBytes),this._metrics=new Tt(Float32Array,0),this._strideInt=s}serialize(t){const e=this._records.buffer(),i=this._indices.buffer(),r=this._vertices.buffer(),s=this._metrics.length?this._metrics.buffer():null,n=4*this._strideInt;return t.push(e,i,r),{stride:n,records:e,indices:i,vertices:r,metrics:s}}get strideInt(){return this._strideInt}get recordCount(){return this._records.length/Ut}get vertexCount(){return this._vertices.length/this._strideInt}get indexCount(){return this._indices.length}get indexWriter(){return this._indices}get vertexWriter(){return this._vertices}get metricWriter(){return this._metrics}vertexEnsureSize(t){this._vertices.ensureSize(t)}indexEnsureSize(t){this._indices.ensureSize(t)}recordStart(){this._start.index=this._indices.length,this._start.vertex=this._vertices.length}recordEnd(t,e,i,r,s,n,o,l){this._records.push(t),this._records.push(e),this._records.push(i),this._records.push(r),this._records.push(s),this._records.push(n),this._records.push(o),this._records.writeF32(l)}writeIndex(t){this._indices.push(t)}writeVertex(t){this._vertices.push(t)}writeVertexF32(t){this._vertices.writeF32(t)}copyLastFrom(t,e,i){const r=t._records.length-Ut,s=t._records.getValue(r),n=t._records.getValue(r+1),o=t._records.getValue(r+2),l=t._records.getValue(r+4),h=t._records.getValue(r+6),c=t._records.getValue(r+7),u=this._vertices.length,d=(t._start.vertex-this._vertices.length)/this._strideInt,_=this._indices.length,m=this.vertexCount;for(let f=t._start.index;f!==t._indices.length;f++){const p=t._indices.getValue(f);this._indices.push(p-d)}for(let f=t._start.vertex;f!==t._vertices.length;f++){const p=t._vertices.getValue(f);this._vertices.push(p)}for(let f=u;f<=this._vertices.length;f+=this._strideInt)this._vertices.i1616Add(f,e,i);this._records.push(s),this._records.push(n),this._records.push(o),this._records.push(_),this._records.push(l),this._records.push(m),this._records.push(h),this._records.push(c)}}const Pt=1,jt=2,It=4,Qt=8,Jt=16,$t=32,te=64,Wt=128;function Re(a){switch(a){case Pt:case Qt:case $t:return-1;case jt:case te:return 0;case It:case Jt:case Wt:return 1}}function Ee(a){switch(a){case Pt:case jt:case It:return-1;case Qt:case Jt:return 0;case $t:case te:case Wt:return 1}}const Be=Pt|Qt|$t,ke=It|Jt|Wt,De=Pt|jt|It,Ve=$t|te|Wt;class Ls{constructor(t,e,i,r,s){this._hasAggregate=!1,this.hasRecords=!1,this._data={self:new Map,neighbors:new Array},this._current={geometryType:0,writer:null,overlaps:0,start:0,insertAfter:0,sortKey:0,id:0,materialKey:0,indexStart:0,vertStart:0,isDotDensity:!1,bufferingEnabled:!1,metricBoxLenPointer:0},this.hint=e,this.tileKey=t,this._hasAggregate=r,this._pixelBufferEnabled=s,this._strideOptions=i}get hasAggregates(){return this._hasAggregate}get hasPixelBufferEnabled(){return this._pixelBufferEnabled}serialize(t){const e=[];return e.push(this._serializeTileVertexData(this.tileKey,this.tileKey,this._data.self)),this._data.neighbors.forEach((i,r)=>{const s=1<<r,n=Re(s),o=Ee(s),l=Xi(new yi(this.tileKey),n,o,t),h=this._serializeTileVertexData(this.tileKey,l.id,i.vertexData);h.message.bufferIds=i.displayIds,e.push(h)}),e}_serializeTileVertexData(t,e,i){var r,s,n,o,l;const h=new Array;return{message:{tileKeyOrigin:t,tileKey:e,data:{[z.MARKER]:(r=i.get(z.MARKER))==null?void 0:r.serialize(h),[z.FILL]:(s=i.get(z.FILL))==null?void 0:s.serialize(h),[z.LINE]:(n=i.get(z.LINE))==null?void 0:n.serialize(h),[z.TEXT]:(o=i.get(z.TEXT))==null?void 0:o.serialize(h),[z.LABEL]:(l=i.get(z.LABEL))==null?void 0:l.serialize(h)}},transferList:h}}featureStart(t,e){this._current.insertAfter=t,this._current.sortKey=e}featureEnd(){}recordStart(t,e,i,r){this._current.writer=this._getVertexWriter(i),this._current.overlaps=0,this._current.indexStart=this._current.writer.indexCount,this._current.vertStart=this._current.writer.vertexCount,this._current.bufferingEnabled=r,this._current.id=t,this._current.materialKey=e,this._current.geometryType=i,this._current.isDotDensity=!1,this._current.writer.recordStart()}recordCount(){return this._current.writer.recordCount}vertexCount(){return this._current.writer.vertexCount}indexCount(){return this._current.writer.indexCount}vertexEnsureSize(t){this._current.writer.vertexEnsureSize(t)}indexEnsureSize(t){this._current.writer.indexEnsureSize(t)}vertexBounds(t,e,i,r){this._current.bufferingEnabled&&this._addOverlap(t,e,i,r)}vertexWrite(t){this._current.writer.writeVertex(t)}vertexWriteF32(t){this._current.writer.writeVertexF32(t)}vertexEnd(){}vertexWriter(){return this._current.writer.vertexWriter}indexWrite(t){this._current.writer.writeIndex(t)}indexWriter(){return this._current.writer.indexWriter}metricWriter(){return this._current.writer.metricWriter}metricStart(t,e,i,r,s,n,o,l){this._current.writer=this._getVertexWriter(z.LABEL);const h=this._current.writer.metricWriter;h.push(Oi(t)),h.push(e),h.push(i),h.push(r),h.push(s),h.push(n),h.push(o),h.push(l),h.push(255),this._current.metricBoxLenPointer=h.push(0)}metricEnd(){const t=this._current.writer.metricWriter;t.getValue(this._current.metricBoxLenPointer)===0&&t.seek(t.length-10)}metricBoxWrite(t,e,i,r){const s=this._current.writer.metricWriter;s.incr(this._current.metricBoxLenPointer),s.push(0),s.push(0),s.push(t),s.push(e),s.push(i),s.push(r)}recordEnd(){const t=this._current.indexStart,e=this._current.writer.indexCount;if(t===e)return!1;this.hasRecords=!0;const i=e-t,r=this._current.vertStart,s=this._current.writer.vertexCount-r;if(this._current.writer.recordEnd(this._current.id,this._current.materialKey,this._current.insertAfter,t,i,r,s,this._current.sortKey),!this._pixelBufferEnabled||this._hasAggregate||this._current.overlaps===0||this._current.geometryType===z.LABEL)return!0;const n=this._current.writer;for(let o=0;o<8;o++){const l=1<<o;if(this._current.overlaps&l){this._data.neighbors[o]||(this._data.neighbors[o]={vertexData:new Map,displayIds:new Set});const h=this._data.neighbors[o],c=this._current.geometryType;if(!h.vertexData.has(c)){const f=Te(c,this._strideOptions).geometry,p=new Ae(c,f,Wi);h.vertexData.set(c,p)}const u=h.vertexData.get(this._current.geometryType),d=8,_=512*-Re(l)*d,m=512*-Ee(l)*d;u.copyLastFrom(n,_,m),h.displayIds.add(this._current.id)}}return!0}_addOverlap(t,e,i,r){const s=255^((t<0+i?ke:t>=nt-i?Be:ke|Be)|(e<0+r?Ve:e>=nt-r?De:Ve|De));this._current.overlaps|=s}_getVertexWriter(t){if(!this._data.self.has(t)){const e=this._data.self,i=Te(t,this._strideOptions).geometry;e.set(t,new Ae(t,i,this.hint.records))}return this._data.self.get(t)}}const D=0,V=100;function Oe(a,t,e){return a[0]=t[0]-e[0],a[1]=t[1]-e[1],a}function Ge(a,t){return Math.sqrt(a*a+t*t)}function Ze(a){const t=Ge(a[0],a[1]);a[0]/=t,a[1]/=t}function cr(a,t){return Ge(a[0]-t[0],a[1]-t[1])}function b(a){return typeof a=="function"}function ee(a=2){return 1/Math.max(a,1)}function Y(a,t){return[!!a.minScale&&t.scaleToZoom(a.minScale)||D,!!a.maxScale&&t.scaleToZoom(a.maxScale)||V]}function ur(a,t){return a[t+1]}function Ke(a){return a.length-1}function fr(a){let t=0;for(let e=0;e<Ke(a);e++)t+=dr(a,e);return t}function dr(a,t,e=1){const[i,r]=ur(a,t);return Math.sqrt(i*i+r*r)*e}class Ct{constructor(t,e,i,r,s){this._segments=t,this._index=e,this._distance=i,this._xStart=r,this._yStart=s,this._done=!1}static create(t){return new Ct(t,0,0,t[0][0],t[0][1])}clone(){return new Ct(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(t){return this._index===t._index||t._index===this._index-1&&(this._distance===0||t._distance===1)||t._index===this._index+1&&(this._distance===1||t._distance===0)}leq(t){return this._index<t._index||this._index===t._index&&this._distance<=t._distance}geq(t){return this._index>t._index||this._index===t._index&&this._distance>=t._distance}get _segment(){return this._segments[this._index+1]}get angle(){const t=this.dy,e=(0*t+-1*-this.dx)/(1*this.length);let i=Math.acos(e);return t>0&&(i=2*Math.PI-i),i}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:t,dy:e}=this;return Math.sqrt(t*t+e*e)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<Ke(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(t,e){const i=this.backwardLength;if(t<=i)return this._distance=(i-t)/this.length,this;let r=this.backwardLength;for(;this.prev();){if(r+this.length>t)return this._seekBackwards(t-r);r+=this.length}return this._distance=0,e?this:null}seek(t,e=!1){if(t<0)return this._seekBackwards(Math.abs(t),e);if(t<=this.remainingLength)return this._distance=(this.backwardLength+t)/this.length,this;let i=this.remainingLength;for(;this.next();){if(i+this.length>t)return this.seek(t-i,e);i+=this.length}return this._distance=1,e?this:null}}function _r(a,t,e,i=!0){const r=fr(a),s=Ct.create(a),n=r/2;if(!i)return s.seek(n),void e(s.clone(),0,n+0*t,r);const o=Math.max((r-t)/2,0),l=Math.floor(o/t),h=n-l*t;s.seek(h);for(let c=-l;c<=l;c++)s.x<512&&s.x>=0&&s.y<512&&s.y>=0&&e(s.clone(),c,n+c*t,r),s.seek(t)}function mr(a,t){const e=t;for(let i=0;i<a.length;i++){let r=a[i];const s=[];s.push(r[0]);for(let o=1;o<r.length;o++){let[l,h]=s[o-1];l+=r[o][0],h+=r[o][1],s.push([l,h])}pr(s,e);const n=[];n.push(s[0]);for(let o=1;o<s.length;o++){const[l,h]=s[o-1],[c,u]=s[o],d=Math.round(c-l),_=Math.round(u-h);n.push([d,_])}a[i]=n,r=n}return a}function pr(a,t){const e=1e-6;if(t<=0)return;const i=a.length;if(i<3)return;const r=[];let s=0;r.push(0);for(let u=1;u<i;u++)s+=cr(a[u],a[u-1]),r.push(s);t=Math.min(t,.2*s);const n=[];n.push(a[0][0]),n.push(a[0][1]);const o=a[i-1][0],l=a[i-1][1],h=Oe([0,0],a[0],a[1]);Ze(h),a[0][0]+=t*h[0],a[0][1]+=t*h[1],Oe(h,a[i-1],a[i-2]),Ze(h),a[i-1][0]+=t*h[0],a[i-1][1]+=t*h[1];for(let u=1;u<i;u++)r[u]+=t;r[i-1]+=t;const c=.5*t;for(let u=1;u<i-1;u++){let d=0,_=0,m=0;for(let f=u-1;f>=0&&!(r[f+1]<r[u]-c);f--){const p=c+r[f+1]-r[u],x=r[f+1]-r[f],y=r[u]-r[f]<c?1:p/x;if(Math.abs(y)<e)break;const M=y*y,v=y*p-.5*M*x,S=y*x/t,L=a[f+1],T=a[f][0]-L[0],P=a[f][1]-L[1];d+=S/v*(L[0]*y*p+.5*M*(p*T-x*L[0])-M*y*x*T/3),_+=S/v*(L[1]*y*p+.5*M*(p*P-x*L[1])-M*y*x*P/3),m+=S}for(let f=u+1;f<i&&!(r[f-1]>r[u]+c);f++){const p=c-r[f-1]+r[u],x=r[f]-r[f-1],y=r[f]-r[u]<c?1:p/x;if(Math.abs(y)<e)break;const M=y*y,v=y*p-.5*M*x,S=y*x/t,L=a[f-1],T=a[f][0]-L[0],P=a[f][1]-L[1];d+=S/v*(L[0]*y*p+.5*M*(p*T-x*L[0])-M*y*x*T/3),_+=S/v*(L[1]*y*p+.5*M*(p*P-x*L[1])-M*y*x*P/3),m+=S}n.push(d/m),n.push(_/m)}n.push(o),n.push(l);for(let u=0,d=0;u<i;u++)a[u][0]=n[d++],a[u][1]=n[d++]}class Xe{static getPlacement(t,e,i){const r=qi(e);if(!r)return null;const s=Hi(t);return r.execute(s,e,i)}}const Ft=8,Ne=a=>class extends a{constructor(...t){super(...t),this._isCIM=!1,this._vertexBoundsScale=1,this.geometryType=z.TEXT,this._aux=W(0,0,this._referenceSize,this._bitset)}bindTextInfo(t,e){t&&t.length?this._shapingInfo=gi(t,i=>ji(i,e,{scale:this._scale,angle:this._angle,xOffset:this._xOffset,yOffset:this._yOffset,hAlign:this._xAlignD,vAlign:this._yAlignD,maxLineWidth:Math.max(32,Math.min(this._lineWidth,512)),lineHeight:Ci*Math.max(.25,Math.min(this._lineHeight,4)),decoration:this._decoration,isCIM:this._isCIM})):this._shapingInfo=null}_write(t,e,i){const r=e.getDisplayId();this._writeGeometry(t,e,r,i)}_writeGeometry(t,e,i,r){const s=this._shapingInfo;if(B(s))return;if(N(this._textPlacement)){const o=r!=null?r:e.readLegacyGeometryForDisplay();return this._writePlacedText(t,i,o,s)}const n=r?Ot(Gt(r),2):e.geometryType==="esriGeometryPolygon"?e.readCentroid():e.readGeometryForDisplay();if(!B(n)){if(n.isPoint){const[o,l]=n.coords;return!t.hasAggregates&&t.hasPixelBufferEnabled&&(o<0||o>=512||l<0||l>=512)?void 0:this._writeGlyphs(t,i,{x:o,y:l},s)}n.forEachVertex((o,l)=>this._writeGlyphs(t,i,{x:o,y:l},s))}}_writePlacedText(t,e,i,r){const s=Zt(this._textPlacement),n=Xe.getPlacement(i,s,g(1));if(!n)return;let o=n.next();for(;o!=null;){const l=o.getAngle();r.setRotation(l);const h=o.tx,c=o.ty;h<0||h>=512||c<0||c>=512||(this._writeGlyphs(t,e,{x:h,y:c},r),r.setRotation(-l)),o=n.next()}}_writeGlyphs(t,e,i,r){const s=Yt.load(this._materialKey),n=w(Math.round(Ft*i.x),Math.round(Ft*i.y)),o=this._vertexBoundsScale,l=r.bounds,h=2*Math.max(l.width,l.height);for(const c of r.glyphs)s.textureBinding=c.textureBinding,t.recordStart(e,s.data,this.geometryType,!0),t.vertexBounds(i.x+l.x+this._xOffset,i.y+l.y-this._yOffset,h*o,h*o),this._writeVertices(t,e,n,c),t.recordEnd()}_writeGlyph(t,e,i,r,s){const n=Yt.load(this._materialKey),o=w(Math.round(Ft*i),Math.round(Ft*r));n.textureBinding=s.textureBinding,t.recordStart(e,n.data,this.geometryType,!0);const l=s.bounds,h=this._vertexBoundsScale;t.vertexBounds(i+l.x*h,r+l.y*h,l.width*h,l.height*h),this._writeVertices(t,e,o,s),t.recordEnd()}_writeVertices(t,e,i,r){const s=t.vertexCount();this._writeVertexCommon(t,e,i,r),t.vertexWrite(r.offsets.upperLeft),t.vertexWrite(r.texcoords.upperLeft),t.vertexEnd(),this._writeVertexCommon(t,e,i,r),t.vertexWrite(r.offsets.upperRight),t.vertexWrite(r.texcoords.upperRight),t.vertexEnd(),this._writeVertexCommon(t,e,i,r),t.vertexWrite(r.offsets.lowerLeft),t.vertexWrite(r.texcoords.lowerLeft),t.vertexEnd(),this._writeVertexCommon(t,e,i,r),t.vertexWrite(r.offsets.lowerRight),t.vertexWrite(r.texcoords.lowerRight),t.vertexEnd(),t.indexWrite(s+0),t.indexWrite(s+1),t.indexWrite(s+2),t.indexWrite(s+1),t.indexWrite(s+3),t.indexWrite(s+2)}_writeVertexCommon(t,e,i,r){const s=this._color,n=this._haloColor,o=W(0,0,this._referenceSize,this._bitset),l=W(0,0,this._size,this._haloSize);t.vertexWrite(i),t.vertexWrite(e),t.vertexWrite(s),t.vertexWrite(n),t.vertexWrite(l),t.vertexWrite(o),t.vertexWrite(this._minMaxZoom)}};class _t{bindFeature(t,e,i){}write(t,e,i){var r;if(B(this._effects)||((r=this._effects)==null?void 0:r.length)===0)return this._write(t,e);const s=Ht.executeEffects(this._effects,e.readLegacyGeometryForDisplay());let n=Ht.next(s);for(;n;)this._write(t,e,n),n=Ht.next(s)}_write(t,e,i){}}const xr=5;class ot extends Ne(_t){constructor(t,e,i,r,s,n,o,l,h,c,u,d,_,m,f,p,x,y,M=!1,v,S){super(),this._xOffset=g(_),this._yOffset=g(m),this._decoration=c||"none",this._color=s,this._haloColor=n,this._haloSize=Math.min(Math.floor(xr*g(Mi(i))),127),this._size=Math.min(Math.round(g(e)),127);const L=Math.min(Math.round(g(r||e)),127);this._referenceSize=Math.round(Math.sqrt(256*L)),this._scale=this._size/Le,this._angle=d,this._justify=Qi(o||"center"),this._xAlignD=Ie(o||"center"),this._yAlignD=$e(l||"baseline"),this._baseline=(l||"baseline")==="baseline",this._bitset=(h===1?1:0)|(u?1:0)<<1;const T=Yt.load(t);T.sdf=!0,this._materialKey=T.data,this._lineWidth=g(f)||512,this._lineHeight=p||1,this._textPlacement=x,this._effects=y,this._isCIM=M,this._minMaxZoom=w(Math.round(v*F),Math.round(S*F))}static fromText(t,e){const i=new ot(t.materialKey,t.font.size,t.haloSize||0,t.font.size,t.color&&Z(t.color)||0,t.haloColor&&Z(t.haloColor)||0,t.horizontalAlignment,t.verticalAlignment,0,t.font.decoration,!1,t.angle||0,t.xoffset,t.yoffset,t.lineWidth,t.lineHeight,null,null,!1,D,V),[,r]=We(t.text);return i.bindTextInfo(e,r),i._vertexBoundsScale=t.maxVVSize?t.maxVVSize/t.font.size:1,i}static fromCIMText(t,e,i){const r=t.scaleFactor||1,s=t.size*t.sizeRatio*r,[n,o]=Y(t.scaleInfo,i),l=new ot(t.materialKey,s,t.outlineSize*t.sizeRatio,t.referenceSize,$(t.color),$(t.outlineColor),t.horizontalAlignment,t.verticalAlignment,t.alignment,t.decoration,t.colorLocked,t.angle,t.offsetX*t.sizeRatio*r,t.offsetY*t.sizeRatio*r,512,1,t.markerPlacement,t.effects,!0,n,o),[,h]=We(t.text);return l.bindTextInfo(e,h),l._vertexBoundsScale=t.maxVVSize?t.maxVVSize/s:1,l}}const yr=st.getLogger("esri.views.2d.engine.webgl.WGLLabelTemplate"),gr=(a,t="mapview-labeling")=>yr.error(new ft(t,a)),At=1,lt=0,Mr=4;function vr(a,t){const e=!!a.minScale&&t.scaleToZoom(a.minScale)||0;return ge(e,0,25.5)}function wr(a,t){const e=!!a.maxScale&&t.scaleToZoom(a.maxScale)||255;return ge(e,0,25.5)}function br(a){const t=new Map;return e=>(t.has(e)||t.set(e,a(e)),t.get(e))}const Sr=br(a=>{let t=0;if(a===0)return 1/0;for(;!(a%2);)t++,a/=2;return t}),Rt=a=>Math.floor(127*a+127),mt=a=>Math.floor(10*a),Et=a=>Math.round(a*(254/360));class Bt extends ot{constructor(t,e,i,r){var s,n,o;super(t,i.font.size,i.haloSize||0,i.font.size,i.color&&Z(i.color)||0,i.haloColor&&Z(i.haloColor)||0,i.horizontalAlignment,i.verticalAlignment,ir(e.labelPlacement)?1:0,i.font.decoration,!1,i.angle||0,i.xoffset,i.yoffset,i.lineWidth,i.lineHeight,null,null,null,null,null),this._outLineLabelAngle=0,this._refPlacementPadding=0,this._refPlacementDirX=0,this._refPlacementDirY=0,this._refOffsetX=0,this._refOffsetY=0,this._zoomLevel=0,this.geometryType=z.LABEL,this._allowOverrun=(s=e.allowOverrun)!=null&&s,this._repeatLabel=(n=e.repeatLabel)==null||n,this._labelPosition=(o=e.labelPosition)!=null?o:"curved";const l=vr(e,r),h=wr(e,r),c=e.labelPlacement,[u,d]=Ji(c);this._xAlignD=u,this._yAlignD=d,this._minZoom=l,this._maxZoom=h,this._refPlacementPadding=g(i.haloSize)+Fi,this._repeatLabelDistance=e.repeatLabelDistance?g(e.repeatLabelDistance):128;const _=rr.load(t);_.sdf=!0,this._materialKey=_.data}static fromLabelClass(t,e){if(t.labelPlacement==="esriServerLinePlacementCenterAlong"){const i=t.symbol;i.xoffset=0,i.yoffset=0,i.angle=0,i.font.decoration="none"}return new Bt(t.materialKey,t,t.symbol,e)}get _shapedBox(){return Zt(this._shapingInfo).bounds}setZoomLevel(t){this._zoomLevel=t}bindReferenceTemplate(t){let e=tr(this._xAlignD),i=er(this._yAlignD);if(this._refOffsetX=0,this._refOffsetY=0,B(t))return void(this._refSymbolAndPlacementOffset=W(0,0,Rt(e),Rt(i)));if(t.boundsType==="circle"&&(e||i)){const n=Math.sqrt(e*e+i*i);e/=n,i/=n}const r=Math.max(t.height,t.width),s=this._refPlacementPadding*Mr;this._refSymbolAndPlacementOffset=W(s,r,Rt(e),Rt(i)),this._referenceSize=r,this._refPlacementDirX=e,this._refPlacementDirY=i,this._refOffsetX=t.xOffset,this._refOffsetY=t.yOffset}_write(t,e){if(B(this._shapingInfo))return;const i=this._shapingInfo,r=e.getDisplayId(),s=e.geometryType==="esriGeometryPolygon"?e.readLegacyCentroid():e.readLegacyGeometry();if(s)switch(this.current={out:t,inId:r,inShaping:i,zoomLevel:this._zoomLevel},e.geometryType){case"esriGeometryPolyline":this._placeLineLabels(s);break;case"esriGeometryPoint":case"esriGeometryPolygon":this._placePointLabels(s);break;default:gr("mapview-labeling",`Geometry of type ${e.geometryType} is not supported`)}}_isVisible(t,e){const i=mt(this.current.zoomLevel);return mt(t)<=i&&i<=mt(e)}_placePointLabels(t){const{out:e,inId:i,inShaping:r}=this.current;this._writeGlyphs(e,i,t,r)}_placeLineLabels(t){const e=mr(t.paths,this.current.inShaping.bounds.width),i=this._placeSubdivGlyphs.bind(this),r=(this._shapedBox.width+this._repeatLabelDistance)/(1<<At);for(const s of e)_r(s,r,i,this._repeatLabel)}_placeSubdivGlyphs(t,e,i,r){const s=Sr(e),n=this._shapedBox.width/(1<<At),o=Math.sqrt(this._repeatLabelDistance)/(1<<At),l=Math.min(i,r-i),h=Math.log2(l/(o+n/2)),c=e===0?h:Math.min(s,h),u=Math.max(this._minZoom,this.current.zoomLevel+At-c),d=this.current.zoomLevel-u,_=this._shapedBox.width/2*2**d;this.current.inShaping.isMultiline?e===0&&this._placeStraight(t,u):this._allowOverrun&&d<0?this._placeStraightAlong(t,this._minZoom):this._labelPosition==="parallel"?this._placeStraightAlong(t,u):this._labelPosition==="curved"&&this._placeCurved(t,u,_)}_placeStraight(t,e){const{out:i,inId:r,inShaping:s}=this.current;this._writeGlyphs(i,r,t,s,e)}_placeCurved(t,e,i){const{out:r,inId:s}=this.current;r.metricStart(s,e,t.x,t.y,0,0,0,0);const n=t.clone(),o=t.angle*(180/Math.PI)%360,l=(t.angle*(180/Math.PI)+180)%360;this._outLineLabelAngle=Et(o),this._placeFirst(n,e,1),this._placeBack(t,n,e,i,1),this._placeForward(t,n,e,i,1),this._outLineLabelAngle=Et(l),this._placeFirst(n,e,0),this._placeBack(t,n,e,i,0),this._placeForward(t,n,e,i,0),r.metricEnd()}_placeStraightAlong(t,e){const{out:i,inId:r}=this.current;i.metricStart(r,e,t.x,t.y,0,0,0,0);const s=t.clone(),n=t.angle*(180/Math.PI)%360,o=(t.angle*(180/Math.PI)+180)%360;this._outLineLabelAngle=Et(n),this._placeFirst(s,e,1,!0),this._outLineLabelAngle=Et(o),this._placeFirst(s,e,0,!0),i.metricEnd()}_placeBack(t,e,i,r,s){const n=t.clone();let o=t.backwardLength+lt;for(;n.prev()&&!(o>=r);)this._placeOnSegment(n,e,o,i,-1,s),o+=n.length+lt}_placeForward(t,e,i,r,s){const n=t.clone();let o=t.remainingLength+lt;for(;n.next()&&!(o>=r);)this._placeOnSegment(n,e,o,i,1,s),o+=n.length+lt}_placeFirst(t,e,i,r=!1){const s=t,n=this.current.inShaping,o=n.glyphs,l=this.current.zoomLevel,{out:h,inId:c}=this.current;for(const u of o){const d=u.x>n.bounds.x?i:1-i,_=d*t.remainingLength+(1-d)*t.backwardLength,m=Math.abs(u.x+u.width/2-n.bounds.x),f=Math.max(0,l+Math.log2(m/(_+lt))),p=Math.max(e,r?0:f);if(u.maxZoom=25,u.angle=t.angle+(1-i)*Math.PI,u.minZoom=p,this._writeGlyph(h,c,s.x,s.y,u),i&&this._isVisible(u.minZoom,u.maxZoom)){const x=u.bounds;h.metricBoxWrite(x.center[0],x.center[1],x.width,x.height)}}}_placeOnSegment(t,e,i,r,s,n){const o=this.current.inShaping.glyphs,{out:l,inId:h}=this.current,c=this.current.inShaping,u=this.current.zoomLevel,d=t.dx/t.length,_=t.dy/t.length,m={x:t.x+i*-s*d,y:t.y+i*-s*_};for(const f of o){const p=f.x>c.bounds.x?n:1-n;if(!(p&&s===1||!p&&s===-1))continue;const x=Math.abs(f.x+f.width/2-c.bounds.x),y=Math.max(0,u+Math.log2(x/i)-.1),M=Math.max(r,u+Math.log2(x/(i+t.length+lt)));if(y!==0&&(f.angle=t.angle+(1-n)*Math.PI,f.minZoom=M,f.maxZoom=y,this._writeGlyph(l,h,m.x,m.y,f),n&&this._isVisible(f.minZoom,f.maxZoom))){const v=f.bounds,S=t.x-e.x,L=t.y-e.y;l.metricBoxWrite(v.center[0]+S,v.center[1]+L,v.width,v.height)}}}_writeGlyphs(t,e,i,r,s=this._minZoom){if(i.x<0||i.x>=512||i.y<0||i.y>=512)return;const n=i.x+this._refOffsetX,o=i.y-this._refOffsetY;for(const u of r.glyphs)u.minZoom=s,u.maxZoom=this._maxZoom,this._writeGlyph(t,e,n,o,u);const l=this._refPlacementDirX,h=this._refPlacementDirY,c=r.boundsT;t.metricStart(e,s,n,o,l,h,this._referenceSize,this._materialKey),t.metricBoxWrite(c.center[0],c.center[1],c.width,c.height),t.metricEnd()}_writeVertexCommon(t,e,i,r){const s=this._color,n=this._haloColor,o=W(0,0,this._size,this._haloSize),l=Math.max(r.minZoom,this._minZoom),h=Math.min(r.maxZoom,this._maxZoom),c=W(mt(l),mt(h),this._outLineLabelAngle,0);t.vertexWrite(i),t.vertexWrite(e),t.vertexWrite(s),t.vertexWrite(n),t.vertexWrite(o),t.vertexWrite(this._refSymbolAndPlacementOffset),t.vertexWrite(c)}}const Ue=3.14159265359/180,Ye=8,qe=a=>class extends a{constructor(...t){super(...t),this.angle=0,this.xOffset=0,this.yOffset=0,this.width=0,this.height=0,this.boundsType="square",this._anchorX=0,this._anchorY=0,this._computedWidth=0,this._computedHeight=0,this._vertexBoundsScaleX=1,this._vertexBoundsScaleY=1,this._offsets={xUpperLeft:0,yUpperLeft:0,xUpperRight:0,yUpperRight:0,xBottomLeft:0,yBottomLeft:0,xBottomRight:0,yBottomRight:0},this.geometryType=z.MARKER}_write(t,e,i){const r=e.getDisplayId();t.recordStart(r,this._materialKey,this.geometryType,!0),this._writeGeometry(t,e,r,i),t.recordEnd()}_writeGeometry(t,e,i,r){if(N(this._markerPlacement))return this._writePlacedMarkers(t,e,r);const s=r?Ot(Gt(r),2):e.geometryType==="esriGeometryPolygon"?e.readCentroid():e.readGeometryForDisplay();if(!B(s)){if(s.isPoint){const[n,o]=s.coords;return!t.hasAggregates&&t.hasPixelBufferEnabled&&(n<0||n>=512||o<0||o>=512)?void 0:this._writeVertices(t,i,this._getPos(n,o),n,o)}s.forEachVertex((n,o)=>this._writeVertices(t,i,this._getPos(n,o),n,o))}}_writePlacedMarkers(t,e,i){const r=i!=null?i:e.readLegacyGeometryForDisplay(),s=Xe.getPlacement(r,Zt(this._markerPlacement),g(1));if(!s)return;const n=e.getDisplayId(),o=Xt(),l=Kt(),h=-128,c=640;let u=s.next();for(;u!=null;){const{tx:d,ty:_}=u;d>=h&&d<=c&&_>=h&&_<=c&&(this._applyTransformation(l,o,u.getAngle()/Ue),this._writeVertices(t,n,this._getPos(d,_),d,_)),u=s.next()}}_writeVertices(t,e,i,r,s){const n=t.vertexCount();t.vertexBounds(r+this.xOffset,s-this.yOffset,this._computedWidth*this._vertexBoundsScaleX,this._computedHeight*this._vertexBoundsScaleY),t.vertexWrite(i),t.vertexWrite(this._offsetUpperLeft),t.vertexWrite(this._texUpperLeft),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),t.vertexWrite(i),t.vertexWrite(this._offsetUpperRight),t.vertexWrite(this._texUpperRight),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),t.vertexWrite(i),t.vertexWrite(this._offsetBottomLeft),t.vertexWrite(this._texBottomLeft),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),t.vertexWrite(i),t.vertexWrite(this._offsetBottomRight),t.vertexWrite(this._texBottomRight),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),t.indexWrite(n+0),t.indexWrite(n+1),t.indexWrite(n+2),t.indexWrite(n+1),t.indexWrite(n+3),t.indexWrite(n+2)}_applyTransformation(t,e,i=0){vi(t),wi(t,t,bi(this.xOffset,-this.yOffset)),this.angle+i!==0&&Si(t,t,Ue*(this.angle+i));const r=this._computedWidth,s=this._computedHeight,n=(this._anchorX-.5)*r,o=(this._anchorY-.5)*s;wt(e,n,o),bt(e,e,t),this._offsetUpperLeft=w(16*e[0],16*e[1]),this._offsets.xUpperLeft=e[0],this._offsets.yUpperLeft=e[1],wt(e,n+r,o),bt(e,e,t),this._offsetUpperRight=w(16*e[0],16*e[1]),this._offsets.xUpperRight=e[0],this._offsets.yUpperRight=e[1],wt(e,n,o+s),bt(e,e,t),this._offsetBottomLeft=w(16*e[0],16*e[1]),this._offsets.xBottomLeft=e[0],this._offsets.yBottomLeft=e[1],wt(e,n+r,o+s),bt(e,e,t),this._offsetBottomRight=w(16*e[0],16*e[1]),this._offsets.xBottomRight=e[0],this._offsets.yBottomRight=e[1]}_getPos(t,e){return w(Math.round(Ye*t),Math.round(Ye*e))}};class O extends qe(_t){constructor(t,e,i,r,s,n,o,l,h,c,u,d,_,m,f,p,x,y,M,v,S,L,T){super(),this.angle=r,this.height=o,this.width=n,this.xOffset=e*M,this.yOffset=i*M,this._markerPlacement=v,this._effects=S,this._anchorX=.5-(.5+p)*f.width/f.width,this._anchorY=.5-(.5+x)*f.height/f.height,this._minMaxZoom=w(Math.round(L*F),Math.round(T*F));const P=(m===1?Ai:Ri)|(u?St:0)|(_?Ei:0)|(d?Bi:0),et=f&&f.sdf,H=Ce.load(t);H.sdf=et,H.pattern=!0,H.textureBinding=f.textureBinding,this._materialKey=H.data,this._fillColor=s,this._outlineColor=h,this._sizeOutlineWidth=W(Math.round(Math.min(Math.sqrt(128*n),255)),Math.round(Math.min(Math.sqrt(128*o),255)),Math.round(Math.min(Math.sqrt(128*c),255)),Math.round(Math.min(Math.sqrt(128*l),255)));const k=f.rect.x+I,j=f.rect.y+I,it=k+f.width,vt=j+f.height;this._offsets.xUpperLeft=k,this._offsets.yUpperLeft=j,this._offsets.xUpperRight=it,this._offsets.yUpperRight=j,this._offsets.xBottomLeft=k,this._offsets.yBottomLeft=vt,this._offsets.xBottomRight=it,this._offsets.yBottomRight=vt,this._texUpperLeft=w(k,j),this._texUpperRight=w(it,j),this._texBottomLeft=w(k,vt),this._texBottomRight=w(it,vt),n*=y,o*=y,n*=M,o*=M;const ci=Math.round(64*y);this._bitestAndDistRatio=w(P,ci),this._computedWidth=n,this._computedHeight=o;const ui=Xt(),fi=Kt();this._applyTransformation(fi,ui)}static fromCIMMarker(t,e,i){const r=e&&e.width||1,s=e&&e.height||1,n=t.size,o=r/s*t.scaleX,l=t.scaleSymbolsProportionally&&t.frameHeight?n/t.frameHeight:1;let h=$(t.color);const c=$(t.outlineColor),u=g(n),d=u*o,_=g(t.offsetX||0),m=g(t.offsetY||0),f=g(t.outlineWidth||0)*l,p=t.alignment||0,x=g(t.referenceSize),[y,M]=Y(t.scaleInfo,i);e.sdf||h!==0||(h=-1);let v=t.rotation||0;t.rotateClockwise||(v=-v);let S=0,L=0;const T=t.anchorPoint;T&&(t.isAbsoluteAnchorPoint?n&&(S=-T.x/(n*o),L=T.y/n):(S=T.x,L=T.y));const P=new O(t.materialKey,_,m,v,h,d,u,x,c,f,t.colorLocked,t.scaleSymbolsProportionally,!1,p,e,S,L,t.sizeRatio,Me(t.scaleFactor,1),t.markerPlacement,t.effects,y,M);return P._vertexBoundsScaleX=t.maxVVSize?t.maxVVSize/d:1,P._vertexBoundsScaleY=t.maxVVSize?t.maxVVSize/u:1,P}static fromPictureMarker(t,e){const i=Math.round(g(t.width)),r=Math.round(g(t.height)),s=ze,n=Math.round(g(t.xoffset||0)),o=Math.round(g(t.yoffset||0)),l=new O(t.materialKey,n,o,t.angle,s,i,r,r,0,0,!1,!1,!1,0,e,0,0,1,1,null,null,D,V);return l._vertexBoundsScaleX=t.maxVVSize?t.maxVVSize/t.width:1,l._vertexBoundsScaleY=t.maxVVSize?t.maxVVSize/t.height:1,l}static fromSimpleMarker(t,e){const i=Z(t.color),r=Math.round(g(t.size)),s=r,n=Math.round(g(t.xoffset||0)),o=Math.round(g(t.yoffset||0)),l=t.style,h=t.outline,c=0|(h&&h.color&&Z(h.color)),u=0|(h&&h.width&&Math.round(g(h.width))),d=new O(t.materialKey,n,o,t.angle,i,r,s,s,c,u,!1,!1,l==="esriSMSCross"||l==="esriSMSX",0,e,0,0,126/64,1,null,null,D,V);return d.boundsType=l==="esriSMSCircle"?"circle":"square",d._vertexBoundsScaleX=t.maxVVSize?t.maxVVSize/t.size:1,d._vertexBoundsScaleY=t.maxVVSize?t.maxVVSize/t.size:1,d}static fromLineSymbolMarker(t,e){const i=Z(t.color),r=6,s=Math.round(g(r*t.lineWidth)),n=s,o=t.style==="cross"||t.style==="x";let l;switch(t.placement){case"begin-end":l="Both";break;case"begin":l="JustBegin";break;case"end":l="JustEnd";break;default:l="None"}const h={type:"CIMMarkerPlacementAtExtremities",angleToLine:!0,offset:0,extremityPlacement:l,offsetAlongLine:0},c=new O(t.materialKey,0,0,0,i,s,n,n/r,i,o?Math.round(g(t.lineWidth)):0,!1,!1,o,1,e,0,0,126/64,1,h,null,D,V);return c.boundsType=t.style==="circle"?"circle":"square",c}}function Lr(a,t,e,i,r,s,n){se=0;const o=(i-e)*s,l=r&&r.length,h=l?(r[0]-e)*s:o;let c,u,d,_,m,f=He(t,e,i,0,h,s,!0);if(f&&f.next!==f.prev){if(l&&(f=Ir(t,e,i,r,f,s)),o>80*s){c=d=t[0+e*s],u=_=t[1+e*s];for(let p=s;p<h;p+=s){const x=t[p+e*s],y=t[p+1+e*s];c=Math.min(c,x),u=Math.min(u,y),d=Math.max(d,x),_=Math.max(_,y)}m=Math.max(d-c,_-u),m=m!==0?1/m:0}xt(f,a,s,c,u,m,n,0)}}function He(a,t,e,i,r,s,n){let o;if(n===Ar(a,t,e,i,r,s)>0)for(let l=i;l<r;l+=s)o=je(l+t*s,a[l+t*s],a[l+1+t*s],o);else for(let l=r-s;l>=i;l-=s)o=je(l+t*s,a[l+t*s],a[l+1+t*s],o);return o&&Q(o,o.next)&&(yt(o),o=o.next),o}function pt(a,t=a){if(!a)return a;let e,i=a;do if(e=!1,i.steiner||!Q(i,i.next)&&C(i.prev,i,i.next)!==0)i=i.next;else{if(yt(i),i=t=i.prev,i===i.next)break;e=!0}while(e||i!==t);return t}function xt(a,t,e,i,r,s,n,o){if(!a)return;!o&&s&&(a=Qe(a,i,r,s));let l=a;for(;a.prev!==a.next;){const h=a.prev,c=a.next;if(s?Tr(a,i,r,s):zr(a))t.push(h.index/e+n),t.push(a.index/e+n),t.push(c.index/e+n),yt(a),a=c.next,l=c.next;else if((a=c)===l){o?o===1?xt(a=Er(a,t,e,n),t,e,i,r,s,n,2):o===2&&Br(a,t,e,i,r,s,n):xt(pt(a),t,e,i,r,s,n,1);break}}}function zr(a){const t=a.prev,e=a,i=a.next;if(C(t,e,i)>=0)return!1;let r=a.next.next;const s=r;let n=0;for(;r!==a.prev&&(n===0||r!==s);){if(n++,ht(t.x,t.y,e.x,e.y,i.x,i.y,r.x,r.y)&&C(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function Tr(a,t,e,i){const r=a.prev,s=a,n=a.next;if(C(r,s,n)>=0)return!1;const o=r.x<s.x?r.x<n.x?r.x:n.x:s.x<n.x?s.x:n.x,l=r.y<s.y?r.y<n.y?r.y:n.y:s.y<n.y?s.y:n.y,h=r.x>s.x?r.x>n.x?r.x:n.x:s.x>n.x?s.x:n.x,c=r.y>s.y?r.y>n.y?r.y:n.y:s.y>n.y?s.y:n.y,u=ie(o,l,t,e,i),d=ie(h,c,t,e,i);let _=a.prevZ,m=a.nextZ;for(;_&&_.z>=u&&m&&m.z<=d;){if(_!==a.prev&&_!==a.next&&ht(r.x,r.y,s.x,s.y,n.x,n.y,_.x,_.y)&&C(_.prev,_,_.next)>=0||(_=_.prevZ,m!==a.prev&&m!==a.next&&ht(r.x,r.y,s.x,s.y,n.x,n.y,m.x,m.y)&&C(m.prev,m,m.next)>=0))return!1;m=m.nextZ}for(;_&&_.z>=u;){if(_!==a.prev&&_!==a.next&&ht(r.x,r.y,s.x,s.y,n.x,n.y,_.x,_.y)&&C(_.prev,_,_.next)>=0)return!1;_=_.prevZ}for(;m&&m.z<=d;){if(m!==a.prev&&m!==a.next&&ht(r.x,r.y,s.x,s.y,n.x,n.y,m.x,m.y)&&C(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function je(a,t,e,i){const r=ct.create(a,t,e);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function yt(a){a.next.prev=a.prev,a.prev.next=a.next,a.prevZ&&(a.prevZ.nextZ=a.nextZ),a.nextZ&&(a.nextZ.prevZ=a.prevZ)}function Pr(a){let t=a,e=a;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==a);return e}function Ir(a,t,e,i,r,s){const n=new Array;for(let o=0,l=i.length;o<l;o++){const h=He(a,t,e,i[o]*s,o<l-1?i[o+1]*s:e*s,s,!1);h===h.next&&(h.steiner=!0),n.push(Pr(h))}n.sort(Rr);for(const o of n)$r(o,r),r=pt(r,r.next);return r}function $r(a,t){if(t=Wr(a,t)){const e=ti(t,a);pt(e,e.next)}}function Wr(a,t){let e=t;const i=a.x,r=a.y;let s,n=-1/0;do{if(r<=e.y&&r>=e.next.y&&e.next.y!==e.y){const d=e.x+(r-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(d<=i&&d>n){if(n=d,d===i){if(r===e.y)return e;if(r===e.next.y)return e.next}s=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!s)return null;if(i===n)return s.prev;const o=s,l=s.x,h=s.y;let c,u=1/0;for(e=s.next;e!==o;)i>=e.x&&e.x>=l&&i!==e.x&&ht(r<h?i:n,r,l,h,r<h?n:i,r,e.x,e.y)&&(c=Math.abs(r-e.y)/(i-e.x),(c<u||c===u&&e.x>s.x)&&gt(e,a)&&(s=e,u=c)),e=e.next;return s}function Qe(a,t,e,i){for(let r;r!==a;r=r.next){if(r=r||a,r.z===null&&(r.z=ie(r.x,r.y,t,e,i)),r.prev.next!==r||r.next.prev!==r)return r.prev.next=r,r.next.prev=r,Qe(a,t,e,i);r.prevZ=r.prev,r.nextZ=r.next}return a.prevZ.nextZ=null,a.prevZ=null,Cr(a)}function Cr(a){let t,e=1;for(;;){let i,r=a;a=null,t=null;let s=0;for(;r;){s++,i=r;let n=0;for(;n<e&&i;n++)i=i.nextZ;let o=e;for(;n>0||o>0&&i;){let l;n===0?(l=i,i=i.nextZ,o--):o!==0&&i?r.z<=i.z?(l=r,r=r.nextZ,n--):(l=i,i=i.nextZ,o--):(l=r,r=r.nextZ,n--),t?t.nextZ=l:a=l,l.prevZ=t,t=l}r=i}if(t.nextZ=null,e*=2,s<2)return a}}function C(a,t,e){return(t.y-a.y)*(e.x-t.x)-(t.x-a.x)*(e.y-t.y)}function Je(a,t,e,i){return!!(Q(a,t)&&Q(e,i)||Q(a,i)&&Q(e,t))||C(a,t,e)>0!=C(a,t,i)>0&&C(e,i,a)>0!=C(e,i,t)>0}function Fr(a,t){let e=a;do{if(e.index!==a.index&&e.next.index!==a.index&&e.index!==t.index&&e.next.index!==t.index&&Je(e,e.next,a,t))return!0;e=e.next}while(e!==a);return!1}function Ar(a,t,e,i,r,s){let n=0;for(let o=i,l=r-s;o<r;o+=s)n+=(a[l+t*s]-a[o+t*s])*(a[o+1+t*s]+a[l+1+t*s]),l=o;return n}function ht(a,t,e,i,r,s,n,o){return(r-n)*(t-o)-(a-n)*(s-o)>=0&&(a-n)*(i-o)-(e-n)*(t-o)>=0&&(e-n)*(s-o)-(r-n)*(i-o)>=0}function gt(a,t){return C(a.prev,a,a.next)<0?C(a,t,a.next)>=0&&C(a,a.prev,t)>=0:C(a,t,a.prev)<0||C(a,a.next,t)<0}function ie(a,t,e,i,r){return(a=1431655765&((a=858993459&((a=252645135&((a=16711935&((a=32767*(a-e)*r)|a<<8))|a<<4))|a<<2))|a<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-i)*r)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function Q(a,t){return a.x===t.x&&a.y===t.y}function Rr(a,t){return a.x-t.x}function Er(a,t,e,i){let r=a;do{const s=r.prev,n=r.next.next;!Q(s,n)&&Je(s,r,r.next,n)&&gt(s,n)&&gt(n,s)&&(t.push(s.index/e+i),t.push(r.index/e+i),t.push(n.index/e+i),yt(r),yt(r.next),r=a=n),r=r.next}while(r!==a);return r}function Br(a,t,e,i,r,s,n){let o=a;do{let l=o.next.next;for(;l!==o.prev;){if(o.index!==l.index&&kr(o,l)){let h=ti(o,l);return o=pt(o,o.next),h=pt(h,h.next),xt(o,t,e,i,r,s,n,0),void xt(h,t,e,i,r,s,n,0)}l=l.next}o=o.next}while(o!==a)}function kr(a,t){return a.next.index!==t.index&&a.prev.index!==t.index&&!Fr(a,t)&&gt(a,t)&&gt(t,a)&&Dr(a,t)}function Dr(a,t){let e=a,i=!1;const r=(a.x+t.x)/2,s=(a.y+t.y)/2;do e.y>s!=e.next.y>s&&e.next.y!==e.y&&r<(e.next.x-e.x)*(s-e.y)/(e.next.y-e.y)+e.x&&(i=!i),e=e.next;while(e!==a);return i}function ti(a,t){const e=ct.create(a.index,a.x,a.y),i=ct.create(t.index,t.x,t.y),r=a.next,s=t.prev;return a.next=t,t.prev=a,e.next=r,r.prev=e,i.next=e,e.prev=i,s.next=i,i.prev=s,i}class ct{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(t,e,i){const r=se<re.length?re[se++]:new ct;return r.index=t,r.x=e,r.y=i,r.prev=null,r.next=null,r.z=null,r.prevZ=null,r.nextZ=null,r.steiner=!1,r}}const re=new Array,Vr=8096;let se=0;for(let a=0;a<Vr;a++)re.push(new ct);const Or=1e-5,J=new Pe(0,0,0,1,0),ne=new Pe(0,0,0,1,0);function ei(a,t,e){let i=0;for(let r=1;r<e;r++){const s=a[2*(t+r-1)],n=a[2*(t+r-1)+1];i+=(a[2*(t+r)]-s)*(a[2*(t+r)+1]+n)}return i}function Gr(a,t,e,i,r){let s=0;const n=2;for(let o=e;o<i;o+=3){const l=(a.getValue(o)-r)*n,h=(a.getValue(o+1)-r)*n,c=(a.getValue(o+2)-r)*n;s+=Math.abs((t[l]-t[c])*(t[h+1]-t[l+1])-(t[l]-t[h])*(t[c+1]-t[l+1]))}return s}function Zr(a,t){const{coords:e,lengths:i,hasIndeterminateRingOrder:r}=t,s=a.indexWriter(),n=a.vertexCount();if(r)return!1;const o=s.length;let l=0;for(let h=0;h<i.length;){let c=h,u=i[h],d=ei(e,l,u);const _=[];for(;++c<i.length;){const x=i[c],y=ei(e,l+u,x);if(!(y>0))break;d+=y,_.push(l+u),u+=x}const m=s.length;Lr(s,e,l,l+u,_,2,n);const f=Gr(s,e,m,s.length,n),p=Math.abs(d);if(Math.abs((f-p)/Math.max(1e-7,p))>Or)return s.seek(o),!1;h=c,l+=u}return!0}function Kr(a,t){const e=a.indexWriter(),i=a.vertexCount(),{coords:r,lengths:s}=t,{buffer:n,vertexCount:o}=Ni(r,s);e.ensureSize(o);for(let l=0;l<o;l++)e.push(l+i);return n}function Xr(a,t,e){let i=0;for(let r=0;r<a.lengths.length;r++){const s=a.lengths[r];for(let n=0;n<s;n++){const o=a.coords[2*(n+i)],l=a.coords[2*(n+i)+1];if(o<t||o>e||l<t||l>e)return!0}i+=s}return!1}function Nr(a,t){if(B(a))return null;if(!Xr(a,-128,nt+128))return a;J.setPixelMargin(t),J.reset(3);let e=0;for(let n=0;n<a.lengths.length;n++){const o=a.lengths[n];let l=a.coords[2*(0+e)],h=a.coords[2*(0+e)+1];J.moveTo(l,h);for(let c=1;c<o;c++)l=a.coords[2*(c+e)],h=a.coords[2*(c+e)+1],J.lineTo(l,h);J.close(),e+=o}const i=J.result(!1);if(!i)return null;const r=[],s=[];for(const n of i){let o=0;for(const l of n)s.push(l.x),s.push(l.y),o++;r.push(o)}return new Li(r,s)}function Ur(a,t){ne.setPixelMargin(t);const e=ne,i=-t,r=nt+t;let s=[],n=!1,o=0;for(;o<a.length;){const l=[],h=a[o];if(!h)return null;e.reset(2);let[c,u]=h[0];if(n)e.moveTo(c,u);else{if(c<i||c>r||u<i||u>r){n=!0;continue}l.push({x:c,y:u})}let d=!1;const _=h.length;for(let m=1;m<_;++m)if(c+=h[m][0],u+=h[m][1],n)e.lineTo(c,u);else{if(c<i||c>r||u<i||u>r){d=!0;break}l.push({x:c,y:u})}if(d)n=!0;else{if(n){const m=e.resultWithStarts();if(m)for(const f of m)s.push(f)}else s.push({line:l,start:0});o++,n=!1}}return s=s.filter(l=>l.line.length>1),s.length===0?null:s}J.setExtent(nt),ne.setExtent(nt);const kt=8,A=16,ii=65535,ri=a=>class extends a{constructor(...t){super(...t),this.tessellationProperties={},this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0},this.geometryType=z.LINE}writeGeometry(t,e,i,r){this._writeGeometry(t,e,i,r)}_initializeTessellator(t){const e=Lt.load(this._materialKey),i=dt.load(this._materialKey),r=this._tessellationOptions,s=e.vvSizeFieldStops||e.vvSizeMinMaxValue||e.vvSizeScaleStops||e.vvSizeUnitValue,n=this.tessellationProperties._halfWidth<ki&&!t&&!s;this.tessellationProperties.minMaxZoom=this._minMaxZoom,r.wrapDistance=ii,r.textured=this._isDashed||this._hasPattern,r.offset=this.tessellationProperties.offset,r.halfWidth=this.tessellationProperties._halfWidth;const o=n?0:1,l=i.outlinedFill?qr:Yr;this._lineTessellator=new Ui(l(this.tessellationProperties,o,o),Hr(this.tessellationProperties),n)}_write(t,e,i){const r=e.geometryType==="esriGeometryPoint";t.recordStart(e.getDisplayId(),this._materialKey,this.geometryType,r),this._writeGeometry(t,e,i,r),t.recordEnd()}_writeGeometry(t,e,i,r){const s=i!=null?i:e.readLegacyGeometryForDisplay(),n=this._getLines(s,r);B(n)||this._writeVertices(t,e,n)}_getLines(t,e){if(B(t))return null;const i=t.paths||t.rings;return B(i)?null:Ur(i,e?256:16)}_writeVertices(t,e,i){const r=e.getDisplayId(),s=t.vertexCount(),n=this.tessellationProperties,o=this._tessellationOptions;n.out=t,n.id=r,n.indexCount=0,n.vertexCount=0,n.offset=s,o.capType=this._capType,o.joinType=this._joinType;const l=dt.load(this._materialKey);this.tessellationProperties.key=l.outlinedFill?l:Lt.load(this._materialKey);for(const{line:h,start:c}of i)o.initialDistance=c%ii,this._lineTessellator.tessellate(h,o)}},Yr=(a,t,e)=>(i,r,s,n,o,l,h,c,u,d,_)=>{const m=w(_,Math.ceil(A*a._halfWidth)),f=W(Math.round(A*h),Math.round(A*c),Math.round(A*u),Math.round(A*d)),p=W(A*o,A*l,0,a._bitset),x=a.out;return x.vertexBounds(i,r,t,e),x.vertexWrite(w(kt*i,kt*r)),x.vertexWrite(a.id),x.vertexWrite(a._fillColor),x.vertexWrite(f),x.vertexWrite(m),x.vertexWrite(a._tl),x.vertexWrite(a._br),x.vertexWrite(p),x.vertexWrite(w(Math.ceil(A*a._halfReferenceWidth),0)),x.vertexWrite(a.minMaxZoom),x.vertexEnd(),a.offset+a.vertexCount++},qr=(a,t,e)=>(i,r,s,n,o,l,h,c,u,d,_)=>{const m=W(0,0,A*a._halfWidth,A*a._halfReferenceWidth),f=W(A*h+128,A*c+128,A*u+128,A*d+128),p=a.out,x=a._bitset<<24|a.id;return p.vertexBounds(i,r,t,e),p.vertexWrite(w(kt*i,kt*r)),p.vertexWrite(x),p.vertexWrite(a._fillColor),a.key.simple||(p.vertexWrite(0),p.vertexWrite(0)),p.vertexWrite(m),p.vertexWrite(f),a.key.simple||p.vertexWrite(a.minMaxZoom),p.vertexEnd(),a.offset+a.vertexCount++},Hr=a=>(t,e,i)=>{const r=a.out;r.indexWrite(t),r.indexWrite(e),r.indexWrite(i),a.indexCount+=3},jr=st.getLogger("esri.views.2d.engine.webgl.WGLLineTemplate");class K extends ri(_t){constructor(t,e,i,r,s,n,o,l,h,c,u,d,_,m,f,p,x,y,M){super();const v=Lt.load(t);e&&(v.sdf=e.sdf,v.pattern=!0,v.textureBinding=e.textureBinding),this._capType=r,this._joinType=s,this._miterLimitCosine=ee(n),this.tessellationProperties._fillColor=o,this.tessellationProperties._tl=l,this.tessellationProperties._br=h,this._hasPattern=c,this._isDashed=u,this._zOrder=p,this._effects=x,this._minMaxZoom=w(Math.round(y*F),Math.round(M*F)),this._materialKey=v.data;const S=(_?St:0)|(m?Di:0)|(d?Vi:0);this.tessellationProperties._bitset=S,this.tessellationProperties._halfWidth=.5*i,this.tessellationProperties._halfReferenceWidth=.5*f,this.tessellationProperties.offset=0,this._initializeTessellator(!1)}static fromCIMLine(t,e,i){const r=t.color,s=t.scaleFactor||1,n=!!t.dashTemplate;let o=t.cap;n&&o===1&&(o=2);const l=t.join,h=g(t.width)*s,c=g(t.referenceWidth),u=g(t.miterLimit),d=r&&$(r)||0,[_,m]=Y(t.scaleInfo,i),f=!1;if(!e)return new K(t.materialKey,e,h,o,l,u,d,0,0,!1,n,t.scaleDash,t.colorLocked,f,c,t.zOrder,t.effects,_,m);const{rect:p,width:x,height:y}=e,M=p.x+I,v=p.y+I,S=M+x,L=v+y,T=w(M,v),P=w(S,L),et=!1;return new K(t.materialKey,e,h,o,l,u,d,T,P,!0,n,t.scaleDash,t.colorLocked,et,c,t.zOrder,t.effects,_,m)}static fromFillOutline(t){var e;return t.isOutlinedFill&&t.outline&&((e=t.outline)==null?void 0:e.style)==="esriSLSSolid"?K.fromSimpleLine(rt({hash:"",materialKey:t.materialKey},t.outline),null,!0):null}static fromSimpleLine(t,e,i=!1){const{color:r}=t,s=t.style!=="esriSLSSolid"&&t.style!=="esriSLSNull",n=Zi(t.cap||"round"),o=Ki(t.join||"round");let l=r&&t.style!=="esriSLSNull"&&Z(r)||0;t.style==="esriSLSNull"&&(l=0);const h=g(t.width),c=t.miterLimit;if(!e)return new K(t.materialKey,e,h,n,o,c,l,0,0,!1,s,!0,!1,i,h,0,null,D,V);const{rect:u,width:d,height:_}=e,m=u.x+I,f=u.y+I,p=m+d,x=f+_,y=w(m,f),M=w(p,x);return new K(t.materialKey,e,h,n,o,c,l,y,M,!0,s,!0,!1,i,h,0,null,D,V)}static fromPictureLineSymbol(t,e,i,r){return jr.error("PictureLineSymbol support does not exist!"),null}}const Qr=100,si=1,ni=a=>class extends a{constructor(...t){super(...t),this.forceLibtess=!1,this._bitset=0,this._lineTemplate=null,this.geometryType=z.FILL}_maybeAddLineTemplate(t){this._lineTemplate=K.fromFillOutline(t)}_write(t,e,i){const r=e.geometryType==="esriGeometryPoint",s=dt.load(this._materialKey);t.recordStart(e.getDisplayId(),this._materialKey,this.geometryType,r),this._writeGeometry(t,e,s,i,r),s.outlinedFill&&N(this._lineTemplate)&&this._lineTemplate.writeGeometry(t,e,i,r),t.recordEnd()}_writeGeometry(t,e,i,r,s){const n=this._getGeometry(e,r,s);if(B(n))return;const o=t.indexCount();if(!(n.maxLength>Qr)&&!this.forceLibtess&&Zr(t,n))return void(o!==t.indexCount()&&this._writeVertices(t,e,n.coords,n.lengths,i));const l=Kr(t,n);o!==t.indexCount()&&this._writeVertices(t,e,l,[l.length/2],i)}_writeVertices(t,e,i,r,s){const n=e.getDisplayId(),o=this._bitset<<24|n;let l=0;const h=r.reduce((u,d)=>u+d),c=s.dotDensity?4:10;t.vertexEnsureSize(c*h);for(const u of r){const d=u+l;for(let _=l;_<d;_++){const m=i[2*_],f=i[2*_+1],p=w(si*m,si*f);t.vertexBounds(m,f,0,0),t.vertexWrite(p),t.vertexWrite(o),s.dotDensity?t.vertexWriteF32(1/Math.abs(e.readGeometryArea())):(t.vertexWrite(this.fillColor),s.simple||(t.vertexWrite(this.tl),t.vertexWrite(this.br)),t.vertexWrite(this.aux2),t.vertexWrite(this.aux3),s.simple||t.vertexWrite(this._minMaxZoom))}l+=u}}_getGeometry(t,e,i){const r=e?Ot(Gt(e),2):t.readGeometryForDisplay();return r?Nr(r,i?256:8):null}},ai=st.getLogger("esri.views.2d.engine.webgl.WGLDynamicMeshTemplate");class Dt extends _t{constructor(t){super(),this._ongoingMaterialRequestMap=new Map,this._materialCache=new Map,this._dynamicPropertyMap=new Map,this._cimLayer=t}analyze(t,e,i,r,s){if(s&&s.length===0)return null;const n=s&&s.length>0,o=e.readLegacyFeature(),l=this._materialCache,h=this._cimLayer.materialHash;if(!h)return ai.error("A Dynamic mesh template must have a material hash value or function!"),Promise.reject(null);const c=typeof h=="function"?h(o,i,r):h;if(l.has(c)){const y=l.get(c);return Promise.resolve(y)}const u=this._ongoingMaterialRequestMap.get(c);if(u)return u;const d=this._cimLayer,_=nr(d.cim,this._cimLayer.materialOverrides);_.mosaicHash=c;const{type:m,url:f}=d,p={cim:_,type:m,mosaicHash:c,url:f,size:null,dashTemplate:null,text:null,fontName:null};switch(m){case"marker":p.size=Nt(d.size,o,i,r);break;case"line":p.dashTemplate=d.dashTemplate;break;case"text":p.text=Nt(d.text,o,i,r),p.fontName=Nt(d.fontName,o,i,r)}const x=t.getMosaicItem(p,s).then(y=>(n||(this._ongoingMaterialRequestMap.delete(c),l.set(c,y)),y)).catch(y=>(this._ongoingMaterialRequestMap.delete(c),ai.error(".analyze()",y.message),null));return n||this._ongoingMaterialRequestMap.set(c,x),x}}const Vt=128;class ae extends ni(Dt){constructor(t,e,i){var r;if(super(t),this._minMaxZoom=w(Math.round(e*F),Math.round(i*F)),b(t.color)){const p=(x,y,M)=>{const v=t.color(x,y,M);return v&&$(v)||0};this._dynamicPropertyMap.set("fillColor",p)}else{const p=t.color;this.fillColor=p&&$(p)||0}let s=0;b(t.height)||(s=t.height||0);const n=((r=t.cim.placement)==null?void 0:r.type)==="CIMMarkerPlacementInsidePolygon"&&t.cim.placement.shiftOddRows?2:1,o=(p,x,y)=>b(t.height)?t.height(p,x,y)*n:s*n;this._dynamicPropertyMap.set("_height",o);let l=0;b(t.offsetX)||(l=g(t.offsetX||0)+Vt,l>255&&(l=255));const h=(p,x,y)=>{if(b(t.offsetX)){let M=g(t.offsetX(p,x,y))+Vt;return M>255&&(M=255),M}return l};this._dynamicPropertyMap.set("_offsetX",h);let c=1;b(t.scaleX)||(c=t.scaleX||1);const u=(p,x,y)=>b(t.scaleX)?t.scaleX(p,x,y):c;this._dynamicPropertyMap.set("_scaleX",u);let d=0;b(t.offsetY)||(d=g(-t.offsetY||0)+Vt,d>255&&(d=255));const _=(p,x,y)=>{if(b(t.offsetY)){let M=g(-t.offsetY(p,x,y))+Vt;return M>255&&(M=255),M}return d};this._dynamicPropertyMap.set("_offsetY",_);let m=0;b(t.angle)||(m=Fe(t.angle)||0);const f=(p,x,y)=>b(t.angle)?Fe(t.angle(p,x,y)):m;this._dynamicPropertyMap.set("_angle",f),this._effects=t.effects,this._cimFillLayer=t,this._fillMaterialKey=dt.load(t.materialKey)}static fromCIMFill(t,e){const[i,r]=Y(t.scaleInfo,e);return new ae(t,i,r)}bindFeature(t,e,i){const r=t.readLegacyFeature();this._dynamicPropertyMap.forEach((c,u)=>{this[u]=c(r,e,i)});const s=this._fillMaterialKey,n=this._materialCache,o=(0,this._cimFillLayer.materialHash)(r,e,i),l=n.get(o);let h=null;if(l&&E(l.spriteMosaicItem)&&(h=l.spriteMosaicItem),h){const{rect:c,width:u,height:d}=h,_=c.x+I,m=c.y+I,f=_+u,p=m+d;let x=Math.round(g(this._height));x>255?x=255:x<=0&&(x=p-m);let y=Math.round(g(this._height/d*u||0));y>255?y=255:y<=0&&(y=f-_);const M=this._scaleX,v=1;this.tl=w(_,m),this.br=w(f,p),this.aux2=W(y,x,this._offsetX,this._offsetY),this.aux3=W(M,v,this._angle,0),s.sdf=h.sdf,s.pattern=!0,s.textureBinding=h.textureBinding}else this.tl=0,this.br=0,this.aux2=0,this.aux3=0,s.sdf=!1,s.pattern=!1,s.textureBinding=0;this._materialKey=s.data}}class oe extends ri(Dt){constructor(t,e,i){super(t),this._minMaxZoom=w(Math.round(e*F),Math.round(i*F)),this._cimLineLayer=t;let r=0;b(t.width)||(r=.5*g(t.width));const s=(n,o,l)=>b(t.width)?.5*g(t.width(n,o,l)):r;if(this._dynamicPropertyMap.set("_halfWidth",s),b(t.cap)?this._dynamicPropertyMap.set("_capType",t.cap):this._capType=t.cap,b(t.join)?this._dynamicPropertyMap.set("_joinType",t.join):this._joinType=t.join,b(t.color)){const n=(o,l,h)=>{const c=t.color(o,l,h);return c&&$(c)||0};this._dynamicPropertyMap.set("_fillColor",n)}else{const n=t.color;this._fillColor=n&&$(n)||0}if(b(t.miterLimit)){const n=(o,l,h)=>ee(t.miterLimit(o,l,h));this._dynamicPropertyMap.set("_miterLimitCosine",n)}else this._miterLimitCosine=ee(t.miterLimit);this._scaleFactor=t.scaleFactor||1,this._isDashed=t.dashTemplate!=null,this._effects=t.effects,this.tessellationProperties._bitset=(t.colorLocked?1:0)|(t.scaleDash?1:0)<<1,this._materialKey=t.materialKey,this._initializeTessellator(!0)}static fromCIMLine(t,e){const[i,r]=Y(t.scaleInfo,e);return new oe(t,i,r)}bindFeature(t,e,i){const r=t.readLegacyFeature();this._dynamicPropertyMap.forEach((c,u)=>{this[u]=c(r,e,i)}),this._halfWidth*=this._scaleFactor;const s=this._materialCache,n=(0,this._cimLineLayer.materialHash)(r,e,i),o=s.get(n);let l=null;if(o&&E(o.spriteMosaicItem)&&(l=o.spriteMosaicItem),l){this._hasPattern=!0;const{rect:c,width:u,height:d}=l,_=c.x+I,m=c.y+I,f=_+u,p=m+d;this.tessellationProperties._tl=w(_,m),this.tessellationProperties._br=w(f,p)}else this._hasPattern=!1,this.tessellationProperties._tl=0,this.tessellationProperties._br=0;this.tessellationProperties._fillColor=this._fillColor,this.tessellationProperties._halfWidth=this._halfWidth,this.tessellationProperties.offset=0,this.tessellationProperties._halfReferenceWidth=this.tessellationProperties._halfWidth;const h=Lt.load(this._materialKey);l&&(h.sdf=l.sdf,h.pattern=!0,h.textureBinding=l.textureBinding),this._materialKey=h.data}}const Jr=Xt(),ts=Kt(),es=st.getLogger("esri.views.2d.engine.webgl.WGLDynamicMarkerTemplate");class le extends qe(Dt){constructor(t,e,i){if(super(t),this._cimMarkerLayer=t,this._minMaxZoom=w(Math.round(e*F),Math.round(i*F)),b(t.color)){const r=(s,n,o)=>$(t.color(s,n,o));this._dynamicPropertyMap.set("_fillColor",r)}else this._fillColor=$(t.color);if(b(t.outlineColor)){const r=(s,n,o)=>$(t.outlineColor(s,n,o));this._dynamicPropertyMap.set("_outlineColor",r)}else this._outlineColor=$(t.outlineColor);if(b(t.size)){const r=(s,n,o)=>g(t.size(s,n,o));this._dynamicPropertyMap.set("_size",r)}else this._size=g(t.size)||0;if(b(t.scaleX)?this._dynamicPropertyMap.set("_scaleX",t.scaleX):this._scaleX=t.scaleX||1,b(t.offsetX)){const r=(s,n,o)=>g(t.offsetX(s,n,o));this._dynamicPropertyMap.set("xOffset",r)}else this.xOffset=g(t.offsetX)||0;if(b(t.offsetY)){const r=(s,n,o)=>g(t.offsetY(s,n,o));this._dynamicPropertyMap.set("yOffset",r)}else this.yOffset=g(t.offsetY)||0;if(b(t.outlineWidth)){const r=(s,n,o)=>g(t.outlineWidth(s,n,o));this._dynamicPropertyMap.set("_outlineWidth",r)}else this._outlineWidth=g(t.outlineWidth)||0;b(t.rotation)?this._dynamicPropertyMap.set("_angle",t.rotation):this._angle=t.rotation||0,this._scaleFactor=Me(t.scaleFactor,1),this._markerPlacement=t.markerPlacement,this._effects=t.effects,this._bitSet=(t.alignment===1?1:0)|(t.colorLocked?1:0)<<1|(t.scaleSymbolsProportionally?1:0)<<3,this._materialKey=t.materialKey}static fromCIMMarker(t,e){const[i,r]=Y(t.scaleInfo,e);return new le(t,i,r)}bindFeature(t,e,i){const r=t.readLegacyFeature();this._dynamicPropertyMap.forEach((j,it)=>{this[it]=j(r,e,i)});const s=this._cimMarkerLayer.materialHash,n=typeof s=="function"?s(r,e,i):s,o=this._materialCache.get(n);if(!o||!E(o.spriteMosaicItem)||!o.spriteMosaicItem)return void es.error(new ft("mapview-cim","Encountered an error when binding feature"));const l=o.spriteMosaicItem,h=this._cimMarkerLayer.sizeRatio,c=l.width/l.height*this._scaleX,u=this._cimMarkerLayer.rotateClockwise?this._angle:-this._angle;let d=this._size,_=d*c;const m=this.xOffset,f=this.yOffset;this.xOffset*=this._scaleFactor,this.yOffset*=this._scaleFactor;const p=this._cimMarkerLayer.scaleSymbolsProportionally&&this._cimMarkerLayer.frameHeight?this._size/g(this._cimMarkerLayer.frameHeight):1,x=this._outlineWidth*p,y=g(this._cimMarkerLayer.referenceSize);let M=0,v=0;const S=this._cimMarkerLayer.anchorPoint;S&&(this._cimMarkerLayer.isAbsoluteAnchorPoint?this._size&&(M=-S.x/(this._size*c),v=S.y/this._size):(M=S.x,v=S.y)),this._sizeOutlineWidth=W(Math.round(Math.min(Math.sqrt(128*_),255)),Math.round(Math.min(Math.sqrt(128*d),255)),Math.round(Math.min(Math.sqrt(128*x),255)),Math.round(Math.min(Math.sqrt(128*y),255))),this.angle=u;const L=Math.round(64*h);this._bitestAndDistRatio=w(this._bitSet,L);const T=l.rect.x+I,P=l.rect.y+I,et=T+l.width,H=P+l.height;this._texUpperLeft=w(T,P),this._texUpperRight=w(et,P),this._texBottomLeft=w(T,H),this._texBottomRight=w(et,H);const k=Ce.load(this._materialKey);k.sdf=l.sdf,k.pattern=!0,k.textureBinding=l.textureBinding,this._materialKey=k.data,this._anchorX=.5-(.5+M)*l.width/l.width,this._anchorY=.5-(.5+v)*l.height/l.height,_*=h,d*=h,_*=this._scaleFactor,d*=this._scaleFactor,_*=l.rect.width/l.width,d*=l.rect.height/l.height,this._computedWidth=_,this._computedHeight=d,this._applyTransformation(ts,Jr),this.xOffset=m,this.yOffset=f}}function oi(a){const t=new Array(a.length);for(let e=0;e<a.length;e++)t[e]=a.charCodeAt(e);return t}const li=5;function is(a,t,e,i){return typeof a.text=="string"?a.text:typeof a.text=="function"?a.text(t,e,i):""}class he extends Ne(Dt){constructor(t,e,i){super(t),this._horizontalAlignment="center",this._verticalAlignment="middle",this._textToGlyphs=new Map,this._minMaxZoom=w(Math.round(e*F),Math.round(i*F));const r=t.scaleFactor||1;if(this._cimTextLayer=t,b(t.color)){const _=(m,f,p)=>$(t.color(m,f,p));this._dynamicPropertyMap.set("_color",_)}else this._color=$(t.color);if(b(t.color)){const _=(m,f,p)=>$(t.outlineColor(m,f,p));this._dynamicPropertyMap.set("_haloColor",_)}else this._haloColor=$(t.outlineColor);let s;b(t.size)||(s=Math.min(Math.round(g(t.size*t.sizeRatio)),127));const n=(_,m,f)=>b(t.size)?Math.min(Math.round(g(t.size(_,m,f)*t.sizeRatio)),127):s;if(this._dynamicPropertyMap.set("_size",n),b(t.outlineSize)){const _=(m,f,p)=>Math.min(Math.floor(li*g(t.outlineSize(m,f,p)*t.sizeRatio)),127);this._dynamicPropertyMap.set("_haloSize",_)}else this._haloSize=Math.min(Math.floor(li*g(t.outlineSize*t.sizeRatio)),127);let o;b(t.offsetX)||(o=Math.round(g(t.offsetX*t.sizeRatio)));const l=(_,m,f)=>b(t.offsetX)?Math.round(g(t.offsetX(_,m,f)*t.sizeRatio)):o;let h;this._dynamicPropertyMap.set("_xOffset",l),b(t.offsetY)||(h=Math.round(g(t.offsetY*t.sizeRatio)));const c=(_,m,f)=>b(t.offsetY)?Math.round(g(t.offsetY(_,m,f)*t.sizeRatio)):h;this._dynamicPropertyMap.set("_yOffset",c),b(t.angle)?this._dynamicPropertyMap.set("_angle",t.angle):this._angle=t.angle,b(t.horizontalAlignment)?this._dynamicPropertyMap.set("_horizontalAlignment",t.horizontalAlignment):this._horizontalAlignment=t.horizontalAlignment,b(t.verticalAlignment)?this._dynamicPropertyMap.set("_verticalAlignment",t.verticalAlignment):this._verticalAlignment=t.verticalAlignment,this._scaleFactor=r,b(t.text)?this._dynamicPropertyMap.set("_text",t.text):this._text=t.text;const u=Math.min(Math.round(g(t.referenceSize*t.sizeRatio)),127);this._referenceSize=Math.round(Math.sqrt(256*u)),this._materialKey=t.materialKey;const d=sr.load(this._materialKey);d.sdf=!0,this._bitset=(t.alignment===1?1:0)|(t.colorLocked?1:0)<<1,this._materialKey=d.data,this._decoration="none",this._lineHeight=1,this._lineWidth=512,this._textPlacement=t.markerPlacement,this._effects=t.effects,this._isCIM=!0}static fromCIMText(t,e){const[i,r]=Y(t.scaleInfo,e);return new he(t,i,r)}async analyze(t,e,i,r){const s=e.readLegacyFeature(),n=is(this._cimTextLayer,s,i,r),o=await super.analyze(t,e,i,r,oi(n));return o&&o.glyphMosaicItems&&this._textToGlyphs.set(n,o.glyphMosaicItems),o}bindFeature(t,e,i){const r=t.readLegacyFeature();if(this._dynamicPropertyMap.forEach((n,o)=>{this[o]=n(r,e,i)}),!this._text||this._text.length===0)return void(this._shapingInfo=null);this._size*=this._scaleFactor,this._scale=this._size/Le,this._xOffset*=this._scaleFactor,this._yOffset*=this._scaleFactor,this._xAlignD=Ie(this._horizontalAlignment||"center"),this._yAlignD=$e(this._verticalAlignment||"baseline");const s=this._textToGlyphs.get(this._text);this.bindTextInfo(s,!1)}}const G=128;class X extends ni(_t){constructor(t,e,i,r,s,n,o,l,h,c,u,d,_,m,f,p){super(),this._effects=m;const x=dt.load(t);e&&(x.sdf=e.sdf,x.pattern=!0,x.textureBinding=e.textureBinding),this.fillColor=i,this.tl=r,this.br=s,this.aux2=W(n,o,l,h),this.aux3=W(c,u,d,0),this._bitset=_,this._minMaxZoom=w(Math.round(f*F),Math.round(p*F)),this._materialKey=x.data}static fromCIMFill(t,e,i){const r=t.color,s=r&&$(r)||0,n=t.materialKey,[o,l]=Y(t.scaleInfo,i);if(!e)return new X(n,null,s,0,0,0,0,0,0,0,0,0,t.colorLocked?1:0,t.effects,o,l);const{rect:h,width:c,height:u}=e,d=t.scaleX||1,_=h.x+I,m=h.y+I,f=_+c,p=m+u,x=t.height,y=d*x;let M=Math.round(x);M>255?M=255:M<=0&&(M=p-m);let v=Math.round(y);v>255?v=255:v<=0&&(v=f-_);let S=g(t.offsetX||0)+G;S>255&&(S=255);let L=g(-t.offsetY||0)+G;L>255&&(L=255);const T=w(_,m),P=w(f,p);return new X(n,e,s,T,P,v,M,S,L,G,G,or(t.angle),t.colorLocked?1:0,t.effects,o,l)}static fromSimpleFill(t,e,i=!1){const{color:r}=t,s=r&&t.style!=="esriSFSNull"&&Z(r)||0,n=i?St:0,o=t.materialKey;let l;if(e){const{rect:h,width:c,height:u}=e,d=h.x+I,_=h.y+I,m=d+c,f=_+u,p=w(d,_),x=w(m,f);l=new X(o,e,s,p,x,c,u,0,0,G,G,0,n,null,D,V)}else l=new X(o,null,s,0,0,0,0,0,0,0,0,0,n,null,D,V);return l._maybeAddLineTemplate(t),l}static fromPictureFill(t,e,i=!1){const r=ze,{rect:s,width:n,height:o}=e,l=s.x+I,h=s.y+I,c=l+n,u=h+o,d=w(l,h),_=w(c,u);let m=Math.round(g(t.width));m>255&&(m=255);let f=Math.round(g(t.height));f>255&&(f=255);let p=g(t.xoffset)+G;p>255&&(p=255);let x=g(-t.yoffset)+G;x>255&&(x=255);const y=t.materialKey,M=i?St:0,v=new X(y,e,r,d,_,m,f,p,x,G*t.xscale,G*t.yscale,0,M,null,D,V);return v._maybeAddLineTemplate(t),v}}class rs{constructor(){this._resolver=null}isHeld(){return!!this._resolver}async acquire(){if(!this._resolver)return this._resolver=zi(),Promise.resolve();await this._resolver.promise,await this.acquire()}release(){const t=this._resolver;this._resolver=null,t.resolve()}}async function ss(a,t,e){try{await a.acquire(),await t(e),a.release()}catch(i){throw a.release(),i}}const R=st.getLogger("esri.views.2d.engine.webgl.mesh.templates.WGLTemplateStore"),hi=new Array,ce={isOutline:!1,isOutlinedFill:!1,placement:null,stride:{fill:"default"},vvFlags:0},ns=ut(rt({},ve),{hash:JSON.stringify(ve),materialKey:qt(z.MARKER,ce)}),as=ut(rt({},we),{hash:JSON.stringify(we),materialKey:qt(z.LINE,ce)}),os=ut(rt({},be),{hash:JSON.stringify(be),materialKey:qt(z.FILL,ce)});function q(a,t){const e=a.length;return a.push(null),t.then(i=>a[e]=i),a}function Mt(a){return!!(1&a)}function ls(a){return a.name==="worker:port-closed"}class zs{constructor(t,e){this._idCounter=1,this._templateIdCounter=1,this._idToTemplateGroup=new Map,this._symbolToTemplate=new Map,this._fetchQueue=[],this._idToResolver=new Map,this._cimTemplateCache=new Map,this._cimAnalyses=[],this._lock=new rs,this._fetchResource=t,this._tileInfo=e}get _markerError(){return this._errorTemplates.marker[0]}get _fillError(){return this._errorTemplates.fill[0]}get _lineError(){return this._errorTemplates.line[0]}get _textError(){return this._errorTemplates.line[0]}createTemplateGroup(t,e){this._initErrorTemplates();const i=t.hash;if(this._symbolToTemplate.has(i))return this._symbolToTemplate.get(i);const r=new Array;e&&this._createMeshTemplates(r,e,!0),this._createMeshTemplates(r,t,!1);const s=this._createGroupId(t.type==="expanded-cim"&&hs(t));return this._idToTemplateGroup.set(s,r),this._symbolToTemplate.set(i,s),s}getTemplateGroup(t){return this._idToTemplateGroup.has(t)?this._idToTemplateGroup.get(t):hi}getDynamicTemplateGroup(t){return this._idToTemplateGroup.has(t)?(Mt(t)||R.error("mapview-template-store",`Id ${t} does not refer to a dynamic template`),this._idToTemplateGroup.get(t)):hi}getMosaicItem(t,e){const i=this._createTemplateId(),r=new Promise(s=>this._idToResolver.set(i,s));return this._fetchQueue.push({symbol:t,id:i,glyphIds:e}),r}finalize(t){return this._fetchQueue.length||this._lock.isHeld()?ss(this._lock,this._fetchAllQueuedResources.bind(this),t):Promise.resolve()}_initErrorTemplates(){this._errorTemplates||(this._errorTemplates={fill:this._createMeshTemplates([],os,!1),marker:this._createMeshTemplates([],ns,!1),line:this._createMeshTemplates([],as,!1)})}_fetchAllQueuedResources(t){if(!this._fetchQueue.length)return Promise.resolve();const e=this._fetchQueue,i=this._cimAnalyses;return this._fetchQueue=[],this._cimAnalyses=[],Promise.all(i).then(()=>this._fetchResource(e,t).then(r=>{for(const{id:s,mosaicItem:n}of r)this._idToResolver.get(s)(n),this._idToResolver.delete(s)})).catch(r=>{Ti(r)?this._fetchQueue=this._fetchQueue.concat(e):ls(r)||R.error(new ft("mapview-template-store","Unable to fetch requested texture resources",r))})}_createGroupId(t){return this._idCounter++<<1|(t?1:0)}_createTemplateId(){return this._templateIdCounter++}async _createSMS(t){const{spriteMosaicItem:e}=await this.getMosaicItem(t);return E(e,R)?O.fromSimpleMarker(t,e):this._markerError}async _createPMS(t){const{spriteMosaicItem:e}=await this.getMosaicItem(t);return E(e,R)?O.fromPictureMarker(t,e):this._markerError}async _createSFS(t,e){const{spriteMosaicItem:i}=await this.getMosaicItem(t);return E(i,R)?X.fromSimpleFill(t,i,e):this._fillError}async _createPFS(t,e){const{spriteMosaicItem:i}=await this.getMosaicItem(t);return E(i,R)?X.fromPictureFill(t,i,e):this._fillError}async _createSLS(t,e){const{spriteMosaicItem:i}=await this.getMosaicItem(t);return E(i,R)?K.fromSimpleLine(t,i):this._lineError}async _createLMS(t){const{spriteMosaicItem:e}=await this.getMosaicItem(t);return E(e,R)?O.fromLineSymbolMarker(t,e):this._markerError}async _createTS(t){const{glyphMosaicItems:e}=await this.getMosaicItem(t);return ot.fromText(t,e)}async _createCIMText(t){const{glyphMosaicItems:e}=await this.getMosaicItem(zt(t),oi(t.text));return E(e,R)?ot.fromCIMText(t,e,this._tileInfo):this._textError}async _createCIMFill(t){const{spriteMosaicItem:e}=await this.getMosaicItem(zt(t));return E(e,R)?X.fromCIMFill(t,e,this._tileInfo):this._fillError}async _createCIMLine(t){const{spriteMosaicItem:e}=await this.getMosaicItem(zt(t));return E(e,R)?K.fromCIMLine(t,e,this._tileInfo):this._lineError}async _createCIMMarker(t){const{spriteMosaicItem:e}=await this.getMosaicItem(zt(t));return E(e,R)?O.fromCIMMarker(t,e,this._tileInfo):this._markerError}async _createCIM(t){const e=t.templateHash;if(this._cimTemplateCache.has(e))return this._cimTemplateCache.get(e);let i;switch(t.type){case"marker":i=this._createCIMMarker(t);break;case"line":i=this._createCIMLine(t);break;case"fill":i=this._createCIMFill(t);break;case"text":i=this._createCIMText(t)}return i.then(r=>this._cimTemplateCache.set(e,r)),i}_createDynamicCIM(t){const e=t.templateHash;if(this._cimTemplateCache.has(e))return this._cimTemplateCache.get(e);let i;switch(t.type){case"marker":i=le.fromCIMMarker(t,this._tileInfo);break;case"line":i=oe.fromCIMLine(t,this._tileInfo);break;case"fill":i=ae.fromCIMFill(t,this._tileInfo);break;case"text":i=he.fromCIMText(t,this._tileInfo)}return this._cimTemplateCache.set(e,i),i}_createPrimitiveMeshTemplates(t,e,i){switch(e.type){case"esriSMS":return q(t,this._createSMS(e));case"esriPMS":return q(t,this._createPMS(e));case"esriSFS":return q(t,this._createSFS(e,i));case"line-marker":return q(t,this._createLMS(e));case"esriPFS":return q(t,this._createPFS(e,i));case"esriSLS":return q(t,this._createSLS(e,!1));case"esriTS":return q(t,this._createTS(e));default:return R.error("Unable to create mesh template for unknown symbol type {: $ }{symbol.type}"),t}}_createMeshTemplates(t,e,i){if(e.type.indexOf("3d")!==-1)return R.error("3D symbols are not supported with MapView"),t;if(e.type==="expanded-cim"){for(const r of e.layers)typeof r.materialHash=="function"?t.push(this._createDynamicCIM(r)):q(t,this._createCIM(r));return t}if(e.type==="composite-symbol"){for(const r of e.layers)this._createPrimitiveMeshTemplates(t,r,i);return t}return e.type==="cim"||e.type==="label"||e.type==="web-style"?t:this._createPrimitiveMeshTemplates(t,e,i)}}const hs=a=>{if(!a.layers)return!1;for(const t of a.layers)if(typeof t.materialHash=="function")return!0;return!1};class Ts{constructor(t,e,i){this._loadPromise=Yi(),this._geometryType=t,this._idField=e,this._templateStore=i}update(t,e){N(t.mesh.labels)&&(this._labelTemplates=this._createLabelTemplates(t.mesh.labels,e)),this._schema=t}_createLabelTemplates(t,e){const i=new Map;if(t.type==="simple"){for(const r of t.classes){const s=Bt.fromLabelClass(r,e);i.set(r.index,s)}return i}for(const r in t.classes){const s=t.classes[r];for(const n of s){const o=Bt.fromLabelClass(n,e);i.set(n.index,o)}}return i}get templates(){return this._templateStore}async analyze(t,e,i,r,s,n,o){if(Se(o))return;let l;i.type==="dictionary"&&(l=await i.analyze(this._idField,t.copy(),e,s,n,o));let h=0;for(;t.next();){let c;if(c=l?l[h++]:N(r)&&Gi(t.getDisplayId())&&t.readAttribute("cluster_count")!==1?r.match(this._idField,t,this._geometryType,s,n):i.match(this._idField,t,this._geometryType,s,n),t.setGroupId(c),Mt(c)){const u=this._templateStore.getDynamicTemplateGroup(c);for(const d of u)d&&d.analyze&&d.analyze(this._templateStore,t,s,n)}}return await this._loadPromise,this._templateStore.finalize(o)}async analyzeGraphics(t,e,i,r,s,n){if(Se(n))return;const o=t.getCursor();for(i&&await i.analyze(this._idField,o.copy(),e,r,s,n);o.next();){let l=o.getGroupId();if(l!=null&&l!==-1||(l=i.match(this._idField,o,o.geometryType,r,s),o.setGroupId(l)),Mt(l)){const h=this._templateStore.getDynamicTemplateGroup(l);for(const c of h)c&&c.analyze&&c.analyze(this._templateStore,o,r,s)}o.setGroupId(l)}return await this._loadPromise,this._templateStore.finalize(n)}writeGraphic(t,e,i){const r=e.getGroupId(),s=e.getDisplayId(),n=this._templateStore.getTemplateGroup(r);if(t.featureStart(e.insertAfter,0),s!=null){if(Mt(r))for(const o of n)o&&o.bindFeature(e,null,null);if(n){for(const o of n)o&&o.write(t,e,i);t.featureEnd()}}}writeCursor(t,e,i,r,s,n){const o=e.getGroupId(),l=e.getDisplayId(),h=this._templateStore.getTemplateGroup(o),c=this._schema.mesh.sortKey;let u=0;if(N(c)&&(u=c.fieldIndex!=null?e.getComputedNumericAtIndex(c.fieldIndex):c.field!=null?e.readAttribute(c.field):e.readAttribute(this._idField),u*=c.order==="asc"?1:-1),t.featureStart(0,u==null||isNaN(u)?0:u),l!=null&&h){if(Mt(o))for(const d of h)d.bindFeature(e,i,r);for(const d of h)d.write(t,e,s);if(N(n)&&t.hasRecords){const d=n&&this._findLabelRef(h);this._writeLabels(t,e,n,d,s)}t.featureEnd()}}_findLabelRef(t){for(const e of t)if(e instanceof O)return e;return null}_writeLabels(t,e,i,r,s){for(const n of i)if(N(n)&&n){const{glyphs:o,rtl:l,index:h}=n,c=this._labelTemplates.get(h);c.setZoomLevel(s),c.bindReferenceTemplate(r),c.bindTextInfo(o,l),c.write(t,e,null)}}}const ue=st.getLogger("esri/views/2d/engine/webgl/util/Matcher");async function cs(a,t,e,i){switch(a.type){case"simple":return tt.fromBasicRenderer(a,t,e,i);case"map":return _e.fromUVRenderer(a,t,e,i);case"interval":return de.fromCBRenderer(a,t,e,i);case"dictionary":return pe.fromDictionaryRenderer(a,t,e,i);case"subtype":return fe.fromSubtypes(a,t,e,i)}}class tt{constructor(){this.type="feature",this._defaultResult=null}static async fromBasicRenderer(t,e,i,r){const s=new tt;if(t.symbol){const n=await U(t.symbol,i,r),o=e.createTemplateGroup(n,null);s.setDefault(o)}return s}size(){return 1}getDefault(){return this._defaultResult}setDefault(t){this._defaultResult=t}match(t,e,i,r,s){return this.getDefault()}async analyze(t,e,i,r,s,n){return null}}class fe extends tt{constructor(t,e){super(),this._subMatchers=t,this._subtypeField=e}static async fromSubtypes(t,e,i,r){const s=new Map,n=[];for(const o in t.renderers){const l=parseInt(o,10),h=cs(t.renderers[o],e,i,r).then(c=>s.set(l,c));n.push(h)}return await Promise.all(n),new fe(s,t.subtypeField)}match(t,e,i,r,s){const n=e.readAttribute(this._subtypeField),o=this._subMatchers.get(n);return o?o.match(t,e,i,r,s):null}}class de extends tt{constructor(t,e,i,r){super(),this.type="interval",this._intervals=[],this._isMaxInclusive=e,this._fieldIndex=r,this._field=t,this._normalizationInfo=i}static async fromCBRenderer(t,e,i,r){const{isMaxInclusive:s,normalizationField:n,normalizationTotal:o,normalizationType:l}=t,h=t.field,c=new de(h,s,{normalizationField:n,normalizationTotal:o,normalizationType:l},t.fieldIndex),u=await U(t.backgroundFillSymbol,i,r);await Promise.all(t.intervals.map(async _=>{const m=await U(_.symbol,i,r),f=await e.createTemplateGroup(m,u),p={min:_.min,max:_.max};c.add(p,f)}));const d=await U(t.defaultSymbol,i,r);if(d){const _=await e.createTemplateGroup(d,u);c.setDefault(_)}return c}add(t,e){this._intervals.push({interval:t,result:e}),this._intervals.sort((i,r)=>i.interval.min-r.interval.min)}size(){return super.size()+this._intervals.length}match(t,e,i,r,s){if(this._fieldIndex==null&&!this._field)return this.getDefault();const n=this._fieldIndex!=null?e.getComputedNumericAtIndex(this._fieldIndex):this._getValueFromField(e);if(!n&&(n==null||isNaN(n)))return this.getDefault();for(let o=0;o<this._intervals.length;o++){const{interval:l,result:h}=this._intervals[o],c=n>=l.min,u=this._isMaxInclusive?n<=l.max:n<l.max;if(c&&u)return h}return this.getDefault()}_needsNormalization(){const t=this._normalizationInfo;return t&&(t.normalizationField||t.normalizationTotal||t.normalizationType)}_getValueFromField(t){const e=t.readAttribute(this._field);if(!this._needsNormalization()||e==null)return e;const{normalizationField:i,normalizationTotal:r,normalizationType:s}=this._normalizationInfo,n=!!i&&t.readAttribute(i);if(s)switch(s){case"esriNormalizeByField":return n?e/n:void 0;case"esriNormalizeByLog":return Math.log(e)*Math.LOG10E;case"esriNormalizeByPercentOfTotal":return e/r*100;default:return void ue.error(`Found unknown normalization type: ${s}`)}else ue.error("Normalization is required, but no type was set!")}}class _e extends tt{constructor(t,e,i){super(),this.type="map",this._nullResult=null,this._resultsMap=new Map,this._fieldsIndex=i,this._fields=t,this._seperator=e||""}static async fromUVRenderer(t,e,i,r){const s=t.fieldDelimiter,n=[t.field];t.field2&&n.push(t.field2),t.field3&&n.push(t.field3);const o=await U(t.backgroundFillSymbol,i,r),l=new _e(n,s,t.fieldIndex);await Promise.all(t.map.map(async c=>{const u=await U(c.symbol,i,r),d=await e.createTemplateGroup(u,o);c.value==="<Null>"?l.setNullResult(d):l.add(c.value,d)}));const h=await U(t.defaultSymbol,i,r);if(h){const c=await e.createTemplateGroup(h,o);l.setDefault(c)}return l}setNullResult(t){this._nullResult=t}add(t,e){this._resultsMap.set(t.toString(),e)}size(){return super.size()+this._resultsMap.size}match(t,e,i,r,s){if(this._fieldsIndex==null&&!this._fields)return this.getDefault();const n=this._fieldsIndex!=null?e.getComputedStringAtIndex(this._fieldsIndex):this._getValueFromFields(e);if(this._nullResult!==null&&(n==null||n===""||n==="<Null>"))return this._nullResult;if(!n&&n==null)return this.getDefault();const o=n.toString();return this._resultsMap.has(o)?this._resultsMap.get(o):this.getDefault()}_getValueFromFields(t){const e=[];for(const i of this._fields){const r=t.readAttribute(i);r==null||r===""?e.push("<Null>"):e.push(r)}return e.join(this._seperator)}}async function us(a,t){const e=a||1;if(typeof e=="number")return(r,s,n)=>e;const i=await $i(e,t.spatialReference,t.fields);return(r,s,n)=>ar(i,r,{$view:n},t.geometryType,s)||1}let me;async function fs(){return me||(me=import("./schemaUtils.a83c8525.js").then(function(a){return a.i})),me}class pe extends tt{constructor(t,e,i,r,s){super(),this.type="dictionary",this._groupIdCache=new Pi(100),this._renderer=t,this._fieldMap=t.fieldMap,this._symbolFields=t.getSymbolFields(),this._templates=e,this._info=i,this._scaleFn=r,this._schemaUtilsModule=s}static async fromDictionaryRenderer(t,e,i,r){const[{default:s},n]=await Promise.all([import("./vendor.1906794a.js").then(function(h){return h.kn}),fs()]),o=s.fromJSON(t.renderer);await o.fetchResources({spatialReference:i.spatialReference,fields:i.fields});const l=await us(o.scaleExpression,i);return new pe(o,e,i,l,n)}async _analyzeFeature(t,e,i,r,s){const n=t.readLegacyFeature(),o=this._scaleFn(n,i,r),l=this._attributeHash(n)+"-"+o,h=this._groupIdCache.get(l);if(h)return h;const c=ut(rt({},r),{spatialReference:this._info.spatialReference,abortOptions:s,fields:this._info.fields}),u=await this._renderer.getSymbolAsync(n,c),d=this._schemaUtilsModule.createSymbolSchema(u,this._renderer),_=U(d,this._info,e,s).then(m=>{if(m.type!=="expanded-cim")return ue.error(new ft("mapview-bad-type",`Found unexpected type ${m.type} in dictionary response`)),null;m.hash+="-"+o;for(const f of m.layers)f.scaleFactor=o,f.templateHash+="-"+o,f.type==="text"&&typeof f.text=="string"&&f.text.indexOf("[")>-1&&(f.text=Ii(this._fieldMap,f.text,f.cim.textCase));return this._templates.createTemplateGroup(m,null)});return this._groupIdCache.put(l,_,1),_}async analyze(t,e,i,r,s,n){const o=e.getCursor(),l=[];for(;o.next();)l.push(this._analyzeFeature(o,i,r,s,n));return Promise.all(l)}match(t,e,i,r,s){return null}_attributeHash(t){let e="";for(const i of this._symbolFields){const r=this._fieldMap[i];r&&(e+=t.attributes[r]+"-")}return e}}export{Ls as E,Tt as a,E as e,zs as j,Ts as l,cs as o,oi as t};
